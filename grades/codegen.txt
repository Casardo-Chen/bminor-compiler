=====STUDENT TESTS=====
====Good Tests====
===[STUDENT TESTS/good0.bminor Input]===
main:function integer ()=
{	
	print 10;
}
===[STUDENT TESTS/good0.bminor Status]===
return code: 0
===[good0.bminor Assembly Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good0.bminor Output]===




===[STUDENT TESTS/good1.bminor Input]===
// tests addition
main:function integer ()=
{
	return 8 + 2;
}
===[STUDENT TESTS/good1.bminor Status]===
return code: 0
===[good1.bminor Assembly Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $8, %rbx
	MOVQ $2, %r10
	ADDQ %rbx, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good1.bminor Output]===




===[STUDENT TESTS/good10.bminor Input]===
// tests character printing
i:char= 'i';
main:function integer () =
{
	n:char ='n';
	print 'h', i,' ', n, 'd'; 
}
===[STUDENT TESTS/good10.bminor Status]===
return code: 0
===[good10.bminor Assembly Output]===
.data
.globl i
i:
	.quad 105
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $110, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $104, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ i, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $32, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $100, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good10.bminor Output]===
i resolves to global i
n resolves to local 0




===[STUDENT TESTS/good11.bminor Input]===
// tests comparisions/if statements
x:integer = 5;
main: function integer () =
{
	y:integer = 10;
	z:integer = 5;
    print "x=",x, '\n';
    print "y=",y, '\n';
    print "z=",z, '\n';
	if(x >= z)
		print "should be printed\n";
	else
	{
		print "shouldn't be printed\n";
	}

	if(y > x )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}
	if(z == x )
	{
		print "should be printed\n";
	}
	else
		print "shouldn't be printed\n";
	
	if(x <= y )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}
	if(x != y )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}


	//switched now (statement should be false)
	if(z < x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}

	if(y < x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	if(z != x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	
	if(y <= x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	if(y == x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
}
===[STUDENT TESTS/good11.bminor Status]===
return code: 0
===[good11.bminor Assembly Output]===
.data
.globl x
x:
	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $10, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $5, %rbx
	MOVQ %rbx, -16(%rbp)
.data
.SL0:
	.string	"x="
.text
	LEAQ .SL0, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ x, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL1:
	.string	"y="
.text
	LEAQ .SL1, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL2:
	.string	"z="
.text
	LEAQ .SL2, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -16(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ x, %rbx
	MOVQ -16(%rbp), %r10
	CMP %r10, %rbx
	JGE .L5
	MOVQ $0, %r10
	JMP .L6
.L5:
	MOVQ $1, %r10
.L6:
	CMP $0, %r10
	JE .L3
.data
.SL7:
	.string	"should be printed\n"
.text
	LEAQ .SL7, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L4
.L3:
.data
.SL8:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL8, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L4:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMP %r10, %rbx
	JG .L11
	MOVQ $0, %r10
	JMP .L12
.L11:
	MOVQ $1, %r10
.L12:
	CMP $0, %r10
	JE .L9
.data
.SL13:
	.string	"should be printed\n"
.text
	LEAQ .SL13, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L10
.L9:
.data
.SL14:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL14, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L10:
	MOVQ -16(%rbp), %rbx
	MOVQ x, %r10
	CMP %r10, %rbx
	JE .L17
	MOVQ $0, %r10
	JMP .L18
.L17:
	MOVQ $1, %r10
.L18:
	CMP $0, %r10
	JE .L15
.data
.SL19:
	.string	"should be printed\n"
.text
	LEAQ .SL19, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L16
.L15:
.data
.SL20:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL20, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L16:
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	CMP %r10, %rbx
	JLE .L23
	MOVQ $0, %r10
	JMP .L24
.L23:
	MOVQ $1, %r10
.L24:
	CMP $0, %r10
	JE .L21
.data
.SL25:
	.string	"should be printed\n"
.text
	LEAQ .SL25, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L22
.L21:
.data
.SL26:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL26, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L22:
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	CMP %r10, %rbx
	JNE .L29
	MOVQ $0, %r10
	JMP .L30
.L29:
	MOVQ $1, %r10
.L30:
	CMP $0, %r10
	JE .L27
.data
.SL31:
	.string	"should be printed\n"
.text
	LEAQ .SL31, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L28
.L27:
.data
.SL32:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL32, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L28:
	MOVQ -16(%rbp), %rbx
	MOVQ x, %r10
	CMP %r10, %rbx
	JL .L35
	MOVQ $0, %r10
	JMP .L36
.L35:
	MOVQ $1, %r10
.L36:
	CMP $0, %r10
	JE .L33
.data
.SL37:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL37, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L34
.L33:
.data
.SL38:
	.string	"should be printed\n"
.text
	LEAQ .SL38, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L34:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMP %r10, %rbx
	JL .L41
	MOVQ $0, %r10
	JMP .L42
.L41:
	MOVQ $1, %r10
.L42:
	CMP $0, %r10
	JE .L39
.data
.SL43:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL43, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L40
.L39:
.data
.SL44:
	.string	"should be printed\n"
.text
	LEAQ .SL44, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L40:
	MOVQ -16(%rbp), %rbx
	MOVQ x, %r10
	CMP %r10, %rbx
	JNE .L47
	MOVQ $0, %r10
	JMP .L48
.L47:
	MOVQ $1, %r10
.L48:
	CMP $0, %r10
	JE .L45
.data
.SL49:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL49, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L46
.L45:
.data
.SL50:
	.string	"should be printed\n"
.text
	LEAQ .SL50, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L46:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMP %r10, %rbx
	JLE .L53
	MOVQ $0, %r10
	JMP .L54
.L53:
	MOVQ $1, %r10
.L54:
	CMP $0, %r10
	JE .L51
.data
.SL55:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL55, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L52
.L51:
.data
.SL56:
	.string	"should be printed\n"
.text
	LEAQ .SL56, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L52:
	MOVQ -8(%rbp), %rbx
	MOVQ x, %r10
	CMP %r10, %rbx
	JE .L59
	MOVQ $0, %r10
	JMP .L60
.L59:
	MOVQ $1, %r10
.L60:
	CMP $0, %r10
	JE .L57
.data
.SL61:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL61, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L58
.L57:
.data
.SL62:
	.string	"should be printed\n"
.text
	LEAQ .SL62, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L58:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good11.bminor Output]===
x resolves to global x
y resolves to local 0
z resolves to local 1
x resolves to global x
z resolves to local 1
y resolves to local 0
x resolves to global x
z resolves to local 1
x resolves to global x
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
z resolves to local 1
x resolves to global x
y resolves to local 0
x resolves to global x
z resolves to local 1
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
x resolves to global x




===[STUDENT TESTS/good12.bminor Input]===
// tests comparisions/if statements with chars
c:char = 'c';
main: function integer () =
{
	a:char = 'a';
	cdup:char = 'c';
	
	if(c == cdup )
	{
		print "should be printed\n";
	}
	else
		print "shouldn't be printed\n";
	
	if(c != a )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}


	//switched now (statement should be false)
	if(c != cdup )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	
	if(c == a )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
}
===[STUDENT TESTS/good12.bminor Status]===
return code: 0
===[good12.bminor Assembly Output]===
.data
.globl c
c:
	.quad 99
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $97, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $99, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ c, %rbx
	MOVQ -16(%rbp), %r10
	CMP %r10, %rbx
	JE .L2
	MOVQ $0, %r10
	JMP .L3
.L2:
	MOVQ $1, %r10
.L3:
	CMP $0, %r10
	JE .L0
.data
.SL4:
	.string	"should be printed\n"
.text
	LEAQ .SL4, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L1
.L0:
.data
.SL5:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL5, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L1:
	MOVQ c, %rbx
	MOVQ -8(%rbp), %r10
	CMP %r10, %rbx
	JNE .L8
	MOVQ $0, %r10
	JMP .L9
.L8:
	MOVQ $1, %r10
.L9:
	CMP $0, %r10
	JE .L6
.data
.SL10:
	.string	"should be printed\n"
.text
	LEAQ .SL10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L7
.L6:
.data
.SL11:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL11, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L7:
	MOVQ c, %rbx
	MOVQ -16(%rbp), %r10
	CMP %r10, %rbx
	JNE .L14
	MOVQ $0, %r10
	JMP .L15
.L14:
	MOVQ $1, %r10
.L15:
	CMP $0, %r10
	JE .L12
.data
.SL16:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL16, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L13
.L12:
.data
.SL17:
	.string	"should be printed\n"
.text
	LEAQ .SL17, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L13:
	MOVQ c, %rbx
	MOVQ -8(%rbp), %r10
	CMP %r10, %rbx
	JE .L20
	MOVQ $0, %r10
	JMP .L21
.L20:
	MOVQ $1, %r10
.L21:
	CMP $0, %r10
	JE .L18
.data
.SL22:
	.string	"shouldn\'t be printed\n"
.text
	LEAQ .SL22, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L19
.L18:
.data
.SL23:
	.string	"should be printed\n"
.text
	LEAQ .SL23, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L19:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good12.bminor Output]===
c resolves to global c
cdup resolves to local 1
c resolves to global c
a resolves to local 0
c resolves to global c
cdup resolves to local 1
c resolves to global c
a resolves to local 0




===[STUDENT TESTS/good13.bminor Input]===
// tests for loops
x:integer = 1;
main: function integer () =
{
	for(x = 0; x<10; x++)
	{
		print x, "\n";
	}
	y:integer = 0;
	for(; y<10; y++)
	{
		print y, "\n";
	}
	x=0;
}
===[STUDENT TESTS/good13.bminor Status]===
return code: 0
===[good13.bminor Assembly Output]===
.data
.globl x
x:
	.quad 1
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ x, %rbx
	MOVQ $0, %r10
	MOVQ %r10, x
.L0:
	MOVQ x, %rbx
	MOVQ $10, %r10
	CMP %r10, %rbx
	JL .L2
	MOVQ $0, %r10
	JMP .L3
.L2:
	MOVQ $1, %r10
.L3:
	CMPQ $0, %r10
	JE .L1
	MOVQ x, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL4:
	.string	"\n"
.text
	LEAQ .SL4, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ x, %rbx
	ADDQ $1, x
	JMP .L0
.L1:
	MOVQ $0, %r10
	MOVQ %r10, -8(%rbp)
.L5:
	MOVQ -8(%rbp), %r10
	MOVQ $10, %r11
	CMP %r11, %r10
	JL .L7
	MOVQ $0, %r11
	JMP .L8
.L7:
	MOVQ $1, %r11
.L8:
	CMPQ $0, %r11
	JE .L6
	MOVQ -8(%rbp), %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
.data
.SL9:
	.string	"\n"
.text
	LEAQ .SL9, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	MOVQ -8(%rbp), %r10
	ADDQ $1, -8(%rbp)
	JMP .L5
.L6:
	MOVQ x, %r11
	MOVQ $0, %r12
	MOVQ %r12, x
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good13.bminor Output]===
x resolves to global x
x resolves to global x
x resolves to global x
x resolves to global x
y resolves to local 0
y resolves to local 0
y resolves to local 0
x resolves to global x




===[STUDENT TESTS/good14.bminor Input]===
// tests infinite for loops
x:integer = 1;
main: function integer () =
{
	for(;;)
	{
		if(x<10)
		{
			print x, "\n";
			x++;
		}
		else
		{
			return  10;
		}
	}	
}
===[STUDENT TESTS/good14.bminor Status]===
return code: 0
===[good14.bminor Assembly Output]===
.data
.globl x
x:
	.quad 1
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.L0:
	MOVQ x, %rbx
	MOVQ $10, %r10
	CMP %r10, %rbx
	JL .L4
	MOVQ $0, %r10
	JMP .L5
.L4:
	MOVQ $1, %r10
.L5:
	CMP $0, %r10
	JE .L2
	MOVQ x, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL6:
	.string	"\n"
.text
	LEAQ .SL6, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ x, %rbx
	ADDQ $1, x
	JMP .L3
.L2:
	MOVQ $10, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L3:
	JMP .L0
.L1:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good14.bminor Output]===
x resolves to global x
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good15.bminor Input]===
// tests strings/string assignments and printing 
str:string = "hello";
main:function integer () =
{
	print str;
	str2:string = " world";
	print str2;
}
===[STUDENT TESTS/good15.bminor Status]===
return code: 0
===[good15.bminor Assembly Output]===
.data
.SL0:
	.string "hello"
.globl str
str:
	.quad .SL0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ str, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL1:
	.string	" world"
.text
	LEAQ .SL1, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good15.bminor Output]===
str resolves to global str
str2 resolves to local 0




===[STUDENT TESTS/good16.bminor Input]===
// tests strings and string comparisions
// and use of strings as local variables

str:string = "hello";
str2:string = " world";

main:function integer () =
{
	str3:string = str;
	if(str == str3)
	{
		print str;
	}
	else
	{
		print "shouldn't be printed";
	}
	if(str != str2)
	{
		print str2;
	}
	else
	{
		print "shouldn't be printed";
	}
}
===[STUDENT TESTS/good16.bminor Status]===
return code: 0
===[good16.bminor Assembly Output]===
.data
.SL0:
	.string "hello"
.globl str
str:
	.quad .SL0
.data
.SL1:
	.string " world"
.globl str2
str2:
	.quad .SL1
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ str, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ str, %rbx
	MOVQ -8(%rbp), %r10
	CMP %r10, %rbx
	JE .L4
	MOVQ $0, %r10
	JMP .L5
.L4:
	MOVQ $1, %r10
.L5:
	CMP $0, %r10
	JE .L2
	MOVQ str, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L3
.L2:
.data
.SL6:
	.string	"shouldn\'t be printed"
.text
	LEAQ .SL6, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L3:
	MOVQ str, %rbx
	MOVQ str2, %r10
	CMP %r10, %rbx
	JNE .L9
	MOVQ $0, %r10
	JMP .L10
.L9:
	MOVQ $1, %r10
.L10:
	CMP $0, %r10
	JE .L7
	MOVQ str2, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L8
.L7:
.data
.SL11:
	.string	"shouldn\'t be printed"
.text
	LEAQ .SL11, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.L8:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good16.bminor Output]===
str resolves to global str
str resolves to global str
str3 resolves to local 0
str resolves to global str
str resolves to global str
str2 resolves to global str2
str2 resolves to global str2




===[STUDENT TESTS/good17.bminor Input]===
/*
Display fibonnaci numbers from 0 to 45.
This test exercises the ability of your
compiler to call recursive functions.
*/

fib: function integer ( x: integer ) =
{
	if( x<1 ) {
		return 0;
	} else {
		if(x<2) {
			return 1;
		} else {
			return fib(x-1) + fib(x-2);
		}
	}
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	i: integer;

	print "Table of Fibonnacci Numbers\n";

	for(i=0;i<30;i=i+1) {
		print i, " ", fib(i), "\n";
	}

	return 0;
}

===[STUDENT TESTS/good17.bminor Status]===
return code: 0
===[good17.bminor Assembly Output]===
.text
.globl fib
fib:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	CMP %r10, %rbx
	JL .L2
	MOVQ $0, %r10
	JMP .L3
.L2:
	MOVQ $1, %r10
.L3:
	CMP $0, %r10
	JE .L0
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .fib_epilogue
	JMP .L1
.L0:
	MOVQ -8(%rbp), %rbx
	MOVQ $2, %r10
	CMP %r10, %rbx
	JL .L6
	MOVQ $0, %r10
	JMP .L7
.L6:
	MOVQ $1, %r10
.L7:
	CMP $0, %r10
	JE .L4
	MOVQ $1, %rbx
	MOV %rbx, %rax
	JMP .fib_epilogue
	JMP .L5
.L4:
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	SUBQ %r10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL fib
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ $2, %r11
	SUBQ %r11, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL fib
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	ADDQ %rbx, %r10
	MOV %r10, %rax
	JMP .fib_epilogue
.L5:
.L1:
.fib_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	PUSHQ %rsi
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.SL8:
	.string	"Table of Fibonnacci Numbers\n"
.text
	LEAQ .SL8, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -24(%rbp), %rbx
	MOVQ $0, %r10
	MOVQ %r10, -24(%rbp)
.L9:
	MOVQ -24(%rbp), %rbx
	MOVQ $30, %r10
	CMP %r10, %rbx
	JL .L11
	MOVQ $0, %r10
	JMP .L12
.L11:
	MOVQ $1, %r10
.L12:
	CMPQ $0, %r10
	JE .L10
	MOVQ -24(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL13:
	.string	" "
.text
	LEAQ .SL13, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -24(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL fib
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL14:
	.string	"\n"
.text
	LEAQ .SL14, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -24(%rbp), %rbx
	MOVQ -24(%rbp), %r10
	MOVQ $1, %r11
	ADDQ %r10, %r11
	MOVQ %r11, -24(%rbp)
	JMP .L9
.L10:
	MOVQ $0, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good17.bminor Output]===
x resolves to param 0
x resolves to param 0
fib resolves to global fib
x resolves to param 0
fib resolves to global fib
x resolves to param 0
i resolves to local 2
i resolves to local 2
i resolves to local 2
i resolves to local 2
i resolves to local 2
fib resolves to global fib
i resolves to local 2




===[STUDENT TESTS/good18.bminor Input]===
// tests boolean operations
x:integer = 1;
main: function string () =
{
    y: integer = 12;
	if(x == 1 && y<13)
	{
        if(x > 1 || y<13) print "x= ", x, "\n";
		x++;
        print "should be printed";
	}
	else
	{
        print "shouldn't be printed";
		return  "wrong";
	}	
}
===[STUDENT TESTS/good18.bminor Status]===
return code: 0
===[good18.bminor Assembly Output]===
.data
.globl x
x:
	.quad 1
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $12, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ x, %rbx
	MOVQ $1, %r10
	CMP %r10, %rbx
	JE .L2
	MOVQ $0, %r10
	JMP .L3
.L2:
	MOVQ $1, %r10
.L3:
	MOVQ -8(%rbp), %rbx
	MOVQ $13, %r11
	CMP %r11, %rbx
	JL .L4
	MOVQ $0, %r11
	JMP .L5
.L4:
	MOVQ $1, %r11
.L5:
	ANDQ %r10, %r11
	CMP $0, %r11
	JE .L0
	MOVQ x, %rbx
	MOVQ $1, %r11
	CMP %r11, %rbx
	JG .L8
	MOVQ $0, %r11
	JMP .L9
.L8:
	MOVQ $1, %r11
.L9:
	MOVQ -8(%rbp), %rbx
	MOVQ $13, %r12
	CMP %r12, %rbx
	JL .L10
	MOVQ $0, %r12
	JMP .L11
.L10:
	MOVQ $1, %r12
.L11:
	ORQ %r11, %r12
	CMP $0, %r12
	JE .L6
.data
.SL12:
	.string	"x= "
.text
	LEAQ .SL12, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ x, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL13:
	.string	"\n"
.text
	LEAQ .SL13, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L7
.L6:
.L7:
	MOVQ x, %rbx
	ADDQ $1, x
.data
.SL14:
	.string	"should be printed"
.text
	LEAQ .SL14, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L1
.L0:
.data
.SL15:
	.string	"shouldn\'t be printed"
.text
	LEAQ .SL15, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL16:
	.string	"wrong"
.text
	LEAQ .SL16, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L1:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good18.bminor Output]===
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good19.bminor Input]===
// tests for array
a: array [5] integer = {1,2,3,4,5};

main: function integer () =
{
    x:integer;
	for(x = 0; x<5; x++)
	{
		print a[x], "\n";
	}
}
===[STUDENT TESTS/good19.bminor Status]===
return code: 0
===[good19.bminor Assembly Output]===
.data
.L0:
	.quad 1
	.quad 2
	.quad 3
	.quad 4
	.quad 5
.globl a
a:
	.quad .L0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ $0, %r10
	MOVQ %r10, -8(%rbp)
.L1:
	MOVQ -8(%rbp), %rbx
	MOVQ $5, %r10
	CMP %r10, %rbx
	JL .L3
	MOVQ $0, %r10
	JMP .L4
.L3:
	MOVQ $1, %r10
.L4:
	CMPQ $0, %r10
	JE .L2
	MOVQ a, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ %r11, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL5:
	.string	"\n"
.text
	LEAQ .SL5, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	ADDQ $1, -8(%rbp)
	JMP .L1
.L2:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good19.bminor Output]===
x resolves to local 0
x resolves to local 0
x resolves to local 0
a resolves to global a
x resolves to local 0




===[STUDENT TESTS/good2.bminor Input]===
// tests multiplication
main:function integer ()=
{
	return 5 * 2;
}
===[STUDENT TESTS/good2.bminor Status]===
return code: 0
===[good2.bminor Assembly Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good2.bminor Output]===




===[STUDENT TESTS/good3.bminor Input]===
// tests division
main:function integer ()=
{
	return 20 / 2;
}
===[STUDENT TESTS/good3.bminor Status]===
return code: 0
===[good3.bminor Assembly Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $20, %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good3.bminor Output]===




===[STUDENT TESTS/good4.bminor Input]===
// Adds a global variable
x:integer=5;
main:function integer ()=
{
	print x + x;
}
===[STUDENT TESTS/good4.bminor Status]===
return code: 0
===[good4.bminor Assembly Output]===
.data
.globl x
x:
	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ x, %rbx
	MOVQ x, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good4.bminor Output]===
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good5.bminor Input]===
// Test expo
x:integer=5;
main:function integer ()=
{
	print x ^ 3;
}
===[STUDENT TESTS/good5.bminor Status]===
return code: 0
===[good5.bminor Assembly Output]===
.data
.globl x
x:
	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ x, %rbx
	MOVQ $3, %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	CALL integer_power
	MOVQ %rax, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good5.bminor Output]===
x resolves to global x




===[STUDENT TESTS/good6.bminor Input]===
// Adds a local variable
x:integer=5;
main:function integer ()=
{
y:integer = 2;
	return x * y;
}
===[STUDENT TESTS/good6.bminor Status]===
return code: 0
===[good6.bminor Assembly Output]===
.data
.globl x
x:
	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ x, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good6.bminor Output]===
x resolves to global x
y resolves to local 0




===[STUDENT TESTS/good7.bminor Input]===
// Uses a complex expression
x:integer=5;
main:function integer () =
{
	y:integer = 2;
	print (x + 10) * y - x*4;
    return (x + 10) * y - x*4;
}
===[STUDENT TESTS/good7.bminor Status]===
return code: 0
===[good7.bminor Assembly Output]===
.data
.globl x
x:
	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ x, %rbx
	MOVQ $10, %r10
	ADDQ %rbx, %r10
	MOVQ -8(%rbp), %rbx
	MOVQ %r10, %rax
	IMULQ %rbx
	MOVQ %rax, %rbx
	MOVQ x, %r10
	MOVQ $4, %r11
	MOVQ %r10, %rax
	IMULQ %r11
	MOVQ %rax, %r11
	SUBQ %r11, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ x, %rbx
	MOVQ $10, %r10
	ADDQ %rbx, %r10
	MOVQ -8(%rbp), %rbx
	MOVQ %r10, %rax
	IMULQ %rbx
	MOVQ %rax, %rbx
	MOVQ x, %r10
	MOVQ $4, %r11
	MOVQ %r10, %rax
	IMULQ %r11
	MOVQ %rax, %r11
	SUBQ %r11, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good7.bminor Output]===
x resolves to global x
y resolves to local 0
x resolves to global x
x resolves to global x
y resolves to local 0
x resolves to global x




===[STUDENT TESTS/good8.bminor Input]===
// Uses a complex expression, with a function call
x:integer=5;
fxnCall:function integer() =
{
	return x*4;
}
main:function integer () =
{
	y:integer = 2;
	return (x + 10) * y - fxnCall();
}
===[STUDENT TESTS/good8.bminor Status]===
return code: 0
===[good8.bminor Assembly Output]===
.data
.globl x
x:
	.quad 5
.text
.globl fxnCall
fxnCall:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ x, %rbx
	MOVQ $4, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .fxnCall_epilogue
.fxnCall_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ x, %rbx
	MOVQ $10, %r10
	ADDQ %rbx, %r10
	MOVQ -8(%rbp), %rbx
	MOVQ %r10, %rax
	IMULQ %rbx
	MOVQ %rax, %rbx
	PUSHQ %r10
	PUSHQ %r11
	CALL fxnCall
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	SUBQ %r10, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good8.bminor Output]===
x resolves to global x
x resolves to global x
y resolves to local 0
fxnCall resolves to global fxnCall




===[STUDENT TESTS/good9.bminor Input]===
// tests if statements 
x:integer = 5;
main:function integer () =
{
	if(false)
		x=15;
	else
		x=10;

	if(true)
	{
		return x;
	}
	else
	{
		return 1;
	}	
	
}
===[STUDENT TESTS/good9.bminor Status]===
return code: 0
===[good9.bminor Assembly Output]===
.data
.globl x
x:
	.quad 5
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $0, %rbx
	CMP $0, %rbx
	JE .L0
	MOVQ x, %rbx
	MOVQ $15, %r10
	MOVQ %r10, x
	JMP .L1
.L0:
	MOVQ x, %rbx
	MOVQ $10, %r10
	MOVQ %r10, x
.L1:
	MOVQ $1, %rbx
	CMP $0, %rbx
	JE .L2
	MOVQ x, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L3
.L2:
	MOVQ $1, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L3:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

Test passed successfully!

===[STUDENT TESTS/good9.bminor Output]===
x resolves to global x
x resolves to global x
x resolves to global x




=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
strlen: function integer(s: string);
f: function integer(i: integer);

main: function integer () = {
	if (f(strlen("hi")) > strlen("there")) {print "no\n";}
	if (f(f(strlen("hi"))) > strlen("there")) print "ok\n";

	return 0;
}

f: function integer(i: integer) = {
	return i*2;
}

===[good1.bminor Assembly Output]===
.text
.globl strlen
.text
.globl f
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.SL2:
	.string	"hi"
.text
	LEAQ .SL2, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL3:
	.string	"there"
.text
	LEAQ .SL3, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	CMP %r10, %rbx
	JG .L4
	MOVQ $0, %r10
	JMP .L5
.L4:
	MOVQ $1, %r10
.L5:
	CMP $0, %r10
	JE .L0
.data
.SL6:
	.string	"no\n"
.text
	LEAQ .SL6, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L1
.L0:
.L1:
.data
.SL9:
	.string	"hi"
.text
	LEAQ .SL9, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL10:
	.string	"there"
.text
	LEAQ .SL10, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strlen
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	CMP %r10, %rbx
	JG .L11
	MOVQ $0, %r10
	JMP .L12
.L11:
	MOVQ $1, %r10
.L12:
	CMP $0, %r10
	JE .L7
.data
.SL13:
	.string	"ok\n"
.text
	LEAQ .SL13, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	JMP .L8
.L7:
.L8:
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .f_epilogue
.f_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========

ok

===[good1.bminor Output]===
ok


return code: 0


===[good10.bminor Input]===
w: string = "no";

f: function void (s: string) = {
	{
		w: string = "ok";
		print w, "\n";
		w = "bad!\n";
	}
	print s, ' ', w;
	print " ";
	s = "changed\n";
	print s;
}

main:function integer ()= {
	s: string = "good";
	f(s);
	print s;

	return 0;
}

===[good10.bminor Assembly Output]===
.data
.SL0:
	.string "no"
.globl w
w:
	.quad .SL0
.text
.globl f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.SL1:
	.string	"ok"
.text
	LEAQ .SL1, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL2:
	.string	"\n"
.text
	LEAQ .SL2, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -16(%rbp), %rbx
.data
.SL3:
	.string	"bad!\n"
.text
	LEAQ .SL3, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $32, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ w, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL4:
	.string	" "
.text
	LEAQ .SL4, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
.data
.SL5:
	.string	"changed\n"
.text
	LEAQ .SL5, %r10
	MOVQ %r10, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.f_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.SL6:
	.string	"good"
.text
	LEAQ .SL6, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========

ok
good no changed
good
===[good10.bminor Output]===
ok
good no changed
good

return code: 0


===[good11.bminor Input]===
main: function integer () = {
	x: integer = 20;
	y: integer = x;
	{
		x: integer = 10;
		y = y + x;
	}

	{
		{
			y = y + x;
			x: integer = 2;
			y = y + x;
		}
		y = y + x;
		x: integer = 3;
		y = y + x;
	}
	return y + x;
}

===[good11.bminor Assembly Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $40, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $20, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ $10, %rbx
	MOVQ %rbx, -24(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	MOVQ -24(%rbp), %r11
	ADDQ %r10, %r11
	MOVQ %r11, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	MOVQ -8(%rbp), %r11
	ADDQ %r10, %r11
	MOVQ %r11, -16(%rbp)
	MOVQ $2, %rbx
	MOVQ %rbx, -32(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	MOVQ -32(%rbp), %r11
	ADDQ %r10, %r11
	MOVQ %r11, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	MOVQ -8(%rbp), %r11
	ADDQ %r10, %r11
	MOVQ %r11, -16(%rbp)
	MOVQ $3, %rbx
	MOVQ %rbx, -40(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	MOVQ -40(%rbp), %r11
	ADDQ %r10, %r11
	MOVQ %r11, -16(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -8(%rbp), %r10
	ADDQ %rbx, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========


===[good11.bminor Output]===


return code: 95


===[good12.bminor Input]===
main: function integer () = {
	return 4 + 9 / (-2 - (-5)) + (((2 + 1) * 4) - 1) % 3 * 7 - 8;
}

===[good12.bminor Assembly Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $4, %rbx
	MOVQ $9, %r10
	MOVQ $2, %r11
	NOTQ %r11, %rax
	ADDQ $1, %r11
	MOVQ $5, %r12
	NOTQ %r12, %rax
	ADDQ $1, %r12
	SUBQ %r12, %r11
	MOVQ %r10, %rax
	CQO
	IDIVQ %r11
	MOVQ %rax, %r11
	ADDQ %rbx, %r11
	MOVQ $2, %rbx
	MOVQ $1, %r10
	ADDQ %rbx, %r10
	MOVQ $4, %rbx
	MOVQ %r10, %rax
	IMULQ %rbx
	MOVQ %rax, %rbx
	MOVQ $1, %r10
	SUBQ %r10, %rbx
	MOVQ $3, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rdx, %r10
	MOVQ $7, %rbx
	MOVQ %r10, %rax
	IMULQ %rbx
	MOVQ %rax, %rbx
	ADDQ %r11, %rbx
	MOVQ $8, %r10
	SUBQ %r10, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

TEST NOT PASSED - COMPILE ERROR

===[good12.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good12.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good12.bminor.s:15: Error: number of operands mismatch for `not'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good12.bminor.s:18: Error: number of operands mismatch for `not'

return code: 1


===[good13.bminor Input]===
foo_epilogue: function integer () = {
	return 2;
}

foo: function integer ();

main: function integer () = {
	return foo() * 11;
}

main_epilogue: function integer () = {
	return foo_epilogue() + 3;
}

foo: function integer () = {
	return main_epilogue() - 1;
}

===[good13.bminor Assembly Output]===
.text
.globl foo_epilogue
foo_epilogue:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $2, %rbx
	MOV %rbx, %rax
	JMP .foo_epilogue_epilogue
.foo_epilogue_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl foo
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL foo
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $11, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main_epilogue
main_epilogue:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL foo_epilogue
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $3, %r10
	ADDQ %rbx, %r10
	MOV %r10, %rax
	JMP .main_epilogue_epilogue
.main_epilogue_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl foo
foo:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL main_epilogue
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $1, %r10
	SUBQ %r10, %rbx
	MOV %rbx, %rax
	JMP .foo_epilogue
.foo_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========


===[good13.bminor Output]===


return code: 44


===[good15.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=179

strdup: function string (s: string);

main: function integer () = {
	a: string = "sssss";
	b: string = strdup(a);
	if (a==b) return 22; else return 11;
}

===[good15.bminor Assembly Output]===
.text
.globl strdup
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $16, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.SL0:
	.string	"sssss"
.text
	LEAQ .SL0, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL strdup
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, -16(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	CMP %r10, %rbx
	JE .L3
	MOVQ $0, %r10
	JMP .L4
.L3:
	MOVQ $1, %r10
.L4:
	CMP $0, %r10
	JE .L1
	MOVQ $22, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L2
.L1:
	MOVQ $11, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L2:
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========


===[good15.bminor Output]===


return code: 11


===[good16.bminor Input]===
// https://piazza.com/class/jziupd2lzpm7cy?cid=176

main: function integer() = {
	print "Testing printing literals", '\n', 123, "abc", true, false, 5;
	return 0;
}


===[good16.bminor Assembly Output]===
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
.data
.SL0:
	.string	"Testing printing literals"
.text
	LEAQ .SL0, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $123, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL1:
	.string	"abc"
.text
	LEAQ .SL1, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $1, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_boolean
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_boolean
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $5, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========

Testing printing literals
123abctruefalse5
===[good16.bminor Output]===
Testing printing literals
123abctruefalse5

return code: 0


===[good17.bminor Input]===
a1: integer;
a2: integer = 111;
a3: boolean = false;

A: function integer() = {
	if (a3) return a1 * a2;
	a2: integer = 3;
	if (!!!a3) return a1 + a2;
	return 0;
}

main: function integer() = { return A(); }

===Compiler returned nonzero return code===
parse error: syntax error


===[good17.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good17.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good18.bminor Input]===
b1: integer = 3;
b2: integer = 6;
b3: integer = 9;

B: function integer(b3: integer, b4: integer) = {
	print b1 * b2 + b3 % b4;
	print '\n';
	b3 = 37;
	return b3;
}

main: function integer () = {
	print B(5, 3);
	return b3;
}

===[good18.bminor Assembly Output]===
.data
.globl b1
b1:
	.quad 3
.data
.globl b2
b2:
	.quad 6
.data
.globl b3
b3:
	.quad 9
.text
.globl B
B:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	PUSHQ %rsi
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ b1, %rbx
	MOVQ b2, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r11
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r11
	MOVQ %rdx, %r11
	ADDQ %r10, %r11
	MOVQ %r11, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	MOVQ $37, %r10
	MOVQ %r10, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOV %rbx, %rax
	JMP .B_epilogue
.B_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ $3, %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL B
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ b3, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========

20
37
===[good18.bminor Output]===
20
37

return code: 9


===[good19.bminor Input]===
c1: integer = -1;
c3: integer = 100;

d1: integer = 1;
d2: integer = 2;

C: function integer(c1: integer, c2: integer) = {
	c3: integer = 11;
	c4: integer = 12;
	c5: integer = 13;
	return c1 + c2 + c3 + c4;
}

D: function integer(d1: integer, d2: integer) = {
	d3: integer = -3;
	d4: integer = 4;
	d5: integer = 5;
	return d1 + d2 + d3 - d4;
}

main: function integer() = {
	f: integer = D(6, 7);
	return C(1, 2);
}

===Compiler returned nonzero return code===
c1 resolves to param 0
c2 resolves to param 1
c3 resolves to local 2
c4 resolves to local 3
d1 resolves to param 0
d2 resolves to param 1
d3 resolves to local 2
d4 resolves to local 3
D resolves to global D
C resolves to global C
type error: non-constant initializers for global variables is invalid.
1 type error(s) found.


===[good19.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good19.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good20.bminor Input]===
D: function integer() = {
	d1: integer = 5;
	d2: integer = d1 + 1; //6
	{
		d3: integer = 9;
		d2: integer = d3 + d1 - 3; //11
		d4: integer = -1;
		d2 = d2 + d3; //20
		print d2 - d4, "\n";
	}
	d4: integer = 16;
	print d2 - d4, '\n';
	{
		d4: integer = -2;
		d3: integer = 1000;
		print d3 + 10;
		print "\n";
		print d4;
		print '\n';
	}
	print d4;
	return 3;
}

main: function integer () = {
	return D();
}

===[good20.bminor Assembly Output]===
.text
.globl D
D:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $64, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $5, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, -16(%rbp)
	MOVQ $9, %rbx
	MOVQ %rbx, -24(%rbp)
	MOVQ -24(%rbp), %rbx
	MOVQ -8(%rbp), %r10
	ADDQ %rbx, %r10
	MOVQ $3, %rbx
	SUBQ %rbx, %r10
	MOVQ %r10, -32(%rbp)
	MOVQ $1, %rbx
	NOTQ %rbx, %rax
	ADDQ $1, %rbx
	MOVQ %rbx, -40(%rbp)
	MOVQ -32(%rbp), %rbx
	MOVQ -32(%rbp), %r10
	MOVQ -24(%rbp), %r11
	ADDQ %r10, %r11
	MOVQ %r11, -32(%rbp)
	MOVQ -32(%rbp), %rbx
	MOVQ -40(%rbp), %r10
	SUBQ %r10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL0:
	.string	"\n"
.text
	LEAQ .SL0, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $16, %rbx
	MOVQ %rbx, -48(%rbp)
	MOVQ -16(%rbp), %rbx
	MOVQ -48(%rbp), %r10
	SUBQ %r10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $2, %rbx
	NOTQ %rbx, %rax
	ADDQ $1, %rbx
	MOVQ %rbx, -56(%rbp)
	MOVQ $1000, %rbx
	MOVQ %rbx, -64(%rbp)
	MOVQ -64(%rbp), %rbx
	MOVQ $10, %r10
	ADDQ %rbx, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL1:
	.string	"\n"
.text
	LEAQ .SL1, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -56(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -48(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $3, %rbx
	MOV %rbx, %rax
	JMP .D_epilogue
.D_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL D
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

TEST NOT PASSED - COMPILE ERROR

===[good20.bminor Output]===

/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good20.bminor.s: Assembler messages:
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good20.bminor.s:27: Error: number of operands mismatch for `not'
/escnfs/home/dsimone2/compilers-fa23-solution/hidden-tests/codegen/good20.bminor.s:78: Error: number of operands mismatch for `not'

return code: 1


===[good3.bminor Input]===
T: array [8] integer = {2, 1, 1, 2, 1, 2, 0, 3};

main:function integer ()=
{
	i: integer = 0;
        for (;;) {
		if (T[i] == 0) return T[5] + 10;
		else if (T[i] == 1) i++;
		else if (T[i] == 2) T[i++]--;
		else return 1;
	}

	return 0;
}

===[good3.bminor Assembly Output]===
.data
.L0:
	.quad 2
	.quad 1
	.quad 1
	.quad 2
	.quad 1
	.quad 2
	.quad 0
	.quad 3
.globl T
T:
	.quad .L0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $0, %rbx
	MOVQ %rbx, -8(%rbp)
.L1:
	MOVQ T, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ $0, %rbx
	CMP %rbx, %r11
	JE .L5
	MOVQ $0, %rbx
	JMP .L6
.L5:
	MOVQ $1, %rbx
.L6:
	CMP $0, %rbx
	JE .L3
	MOVQ T, %rbx
	MOVQ $5, %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ $10, %rbx
	ADDQ %r11, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L4
.L3:
	MOVQ T, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ $1, %rbx
	CMP %rbx, %r11
	JE .L9
	MOVQ $0, %rbx
	JMP .L10
.L9:
	MOVQ $1, %rbx
.L10:
	CMP $0, %rbx
	JE .L7
	MOVQ -8(%rbp), %rbx
	ADDQ $1, -8(%rbp)
	JMP .L8
.L7:
	MOVQ T, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ $2, %rbx
	CMP %rbx, %r11
	JE .L13
	MOVQ $0, %rbx
	JMP .L14
.L13:
	MOVQ $1, %rbx
.L14:
	CMP $0, %rbx
	JE .L11
	MOVQ T, %rbx
	MOVQ -8(%rbp), %r10
	ADDQ $1, -8(%rbp)
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ T, %rbx
	MOVQ -8(%rbp), %r10
	ADDQ $1, -8(%rbp)
	SUBQ $1, (%rbx, %r10, 8)
	JMP .L12
.L11:
	MOVQ $1, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.L12:
.L8:
.L4:
	JMP .L1
.L2:
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========


===[good3.bminor Output]===


return code: 1


===[good2.bminor Input]===


X: array [4] integer = {11, 30, 22, 0};

main: function integer () = {
	i: integer;
	for (i = 0; X[i] != 0; i++)
		print X[i], ' ', X[i] % 3, '\n';

	return 0;
}

===[good2.bminor Assembly Output]===
.data
.L0:
	.quad 11
	.quad 30
	.quad 22
	.quad 0
.globl X
X:
	.quad .L0
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ $0, %r10
	MOVQ %r10, -8(%rbp)
.L1:
	MOVQ X, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ $0, %rbx
	CMP %rbx, %r11
	JNE .L3
	MOVQ $0, %rbx
	JMP .L4
.L3:
	MOVQ $1, %rbx
.L4:
	CMPQ $0, %rbx
	JE .L2
	MOVQ X, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ %r11, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $32, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ X, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ (%rbx, %r10, 8), %r11
	MOVQ $3, %rbx
	MOVQ %r11, %rax
	CQO
	IDIVQ %rbx
	MOVQ %rdx, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $10, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_character
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	ADDQ $1, -8(%rbp)
	JMP .L1
.L2:
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========

11 2
30 0
22 1

===[good2.bminor Output]===
11 2
30 0
22 1


return code: 0


===[good5.bminor Input]===
A: function boolean(x: integer, y: integer);
B: function integer(x: char);
C: function char(a: string);

main: function integer() = {
	if (A(B('d') - 1, 10)) {
		x: integer = 3;
		return 2 * B('!') + x;
	}
	return B(C("hello")) % 3;
}

A: function boolean(x: integer, y: integer) = {
	return x == y;
}

B: function integer(c: char) = {
	if (c == '!')
		return 10;
	else {return 11;}
}

C: function char(a: string) = {
	return '!';
}

===[good5.bminor Assembly Output]===
.text
.globl A
.text
.globl B
.text
.globl C
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $100, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL B
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $1, %r10
	SUBQ %r10, %rbx
	MOVQ $10, %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL A
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	CMP $0, %rbx
	JE .L0
	MOVQ $3, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ $2, %rbx
	MOVQ $33, %r10
	MOVQ %r10, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL B
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOVQ -8(%rbp), %rbx
	ADDQ %r10, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
	JMP .L1
.L0:
.L1:
.data
.SL2:
	.string	"hello"
.text
	LEAQ .SL2, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL C
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL B
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $3, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rdx, %r10
	MOV %r10, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl A
A:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	PUSHQ %rsi
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ -16(%rbp), %r10
	CMP %r10, %rbx
	JE .L3
	MOVQ $0, %r10
	JMP .L4
.L3:
	MOVQ $1, %r10
.L4:
	MOV %r10, %rax
	JMP .A_epilogue
.A_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl B
B:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ $33, %r10
	CMP %r10, %rbx
	JE .L7
	MOVQ $0, %r10
	JMP .L8
.L7:
	MOVQ $1, %r10
.L8:
	CMP $0, %r10
	JE .L5
	MOVQ $10, %rbx
	MOV %rbx, %rax
	JMP .B_epilogue
	JMP .L6
.L5:
	MOVQ $11, %rbx
	MOV %rbx, %rax
	JMP .B_epilogue
.L6:
.B_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl C
C:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $33, %rbx
	MOV %rbx, %rax
	JMP .C_epilogue
.C_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========


===[good5.bminor Output]===


return code: 23


===[good6.bminor Input]===
f: function boolean(b: boolean) = {
	return !b;
}

x: integer = -4;

main:function integer ()=
{
	y: integer = 10;
	if (f(f(f(f(f(x <= y)))))) return 1;
	else if (x < y - x*y) {
		return 4;
	} else return 2;
}

===Compiler returned nonzero return code===
b resolves to param 0
f resolves to global f
f resolves to global f
f resolves to global f
f resolves to global f
f resolves to global f
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
type error: non-constant initializers for global variables is invalid.
1 type error(s) found.


===[good6.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good6.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good7.bminor Input]===
f: function void (i: integer) = {
	N: integer;
	for (N = 0; i > 0; i--) {
		print N;
		N = N + 1;
	}
}

main:function integer () = {
	N: integer = 6;
	for (;;N--) {
		f(N);
		print '\n';
		if (N == 0) return 0;
	}

	return 1;
}

===Compiler returned nonzero return code===


===[good7.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good7.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good8.bminor Input]===
abs: function integer(n: integer);

digits: array [6] integer = {
	14,
	8,
	6168,
	42,
	0,
	74546
};

main:function integer () = {
	digits[4] = -468;
	i: integer = 0;
	for (; abs(digits[i]) == digits[i];) {
		print digits[i];
		i = i + 1;
		print ' ';
	}
	print '\n';

	return 0;
}

===Compiler returned nonzero return code===


===[good8.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good8.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good9.bminor Input]===
a: array[4] integer;
main: function integer() = {
	a[2] = 60;
	return a[2] + a[2] / 20 * 3 - a[1];
}

===Compiler returned nonzero return code===


===[good9.bminor Assembly Output]===

TEST NOT PASSED - COMPILE ERROR

===[good9.bminor Output]===

/usr/lib/gcc/x86_64-redhat-linux/8/../../../../lib64/crt1.o: In function `_start':
(.text+0x24): undefined reference to `main'
collect2: error: ld returned 1 exit status

return code: 1


===[good14.bminor Input]===
/*
Return pointer to (constant) global
string which is valid to display.
*/

s: string = "ok\n";

f: function string() = {
	t: string = s;
	return t;
}

main: function integer () = {
	print f();
	return 0;
}

===[good14.bminor Assembly Output]===
.data
.SL0:
	.string "ok\n"
.globl s
s:
	.quad .SL0
.text
.globl f
f:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $8, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ s, %rbx
	MOVQ %rbx, -8(%rbp)
	MOVQ -8(%rbp), %rbx
	MOV %rbx, %rax
	JMP .f_epilogue
.f_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	PUSHQ %r10
	PUSHQ %r11
	CALL f
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ $0, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========

ok

===[good14.bminor Output]===
ok


return code: 0


===[good4.bminor Input]===
collatz: function integer(n: integer, acc: integer) = {
	print n, " ", acc, "\n";
	if (n == 1) return acc;

	if (n % 2 == 0) return collatz(n/2, acc + 1);
	else return collatz(3*n + 1, acc + 1);
}

main:function integer ()=
{
	return collatz(27, 0);
}

===[good4.bminor Assembly Output]===
.text
.globl collatz
collatz:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	PUSHQ %rdi
	PUSHQ %rsi
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ -8(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL0:
	.string	" "
.text
	LEAQ .SL0, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -16(%rbp), %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_integer
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
.data
.SL1:
	.string	"\n"
.text
	LEAQ .SL1, %rbx
	MOVQ %rbx, %rdi
	PUSHQ %r10
	PUSHQ %r11
	CALL print_string
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOVQ -8(%rbp), %rbx
	MOVQ $1, %r10
	CMP %r10, %rbx
	JE .L4
	MOVQ $0, %r10
	JMP .L5
.L4:
	MOVQ $1, %r10
.L5:
	CMP $0, %r10
	JE .L2
	MOVQ -16(%rbp), %rbx
	MOV %rbx, %rax
	JMP .collatz_epilogue
	JMP .L3
.L2:
.L3:
	MOVQ -8(%rbp), %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rdx, %r10
	MOVQ $0, %rbx
	CMP %rbx, %r10
	JE .L8
	MOVQ $0, %rbx
	JMP .L9
.L8:
	MOVQ $1, %rbx
.L9:
	CMP $0, %rbx
	JE .L6
	MOVQ -8(%rbp), %rbx
	MOVQ $2, %r10
	MOVQ %rbx, %rax
	CQO
	IDIVQ %r10
	MOVQ %rax, %r10
	MOVQ -16(%rbp), %rbx
	MOVQ $1, %r11
	ADDQ %rbx, %r11
	MOVQ %r10, %rdi
	MOVQ %r11, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL collatz
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOV %rbx, %rax
	JMP .collatz_epilogue
	JMP .L7
.L6:
	MOVQ $3, %rbx
	MOVQ -8(%rbp), %r10
	MOVQ %rbx, %rax
	IMULQ %r10
	MOVQ %rax, %r10
	MOVQ $1, %rbx
	ADDQ %r10, %rbx
	MOVQ -16(%rbp), %r10
	MOVQ $1, %r11
	ADDQ %r10, %r11
	MOVQ %rbx, %rdi
	MOVQ %r11, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL collatz
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOV %rbx, %rax
	JMP .collatz_epilogue
.L7:
.collatz_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET
.text
.globl main
main:
	PUSHQ %rbp
	MOVQ %rsp, %rbp
	SUBQ $0, %rsp
	PUSHQ %rbx
	PUSHQ %r12
	PUSHQ %r13
	PUSHQ %r14
	PUSHQ %r15
	MOVQ $27, %rbx
	MOVQ $0, %r10
	MOVQ %rbx, %rdi
	MOVQ %r10, %rsi
	PUSHQ %r10
	PUSHQ %r11
	CALL collatz
	POPQ %r11
	POPQ %r10
	MOVQ %rax, %rbx
	MOV %rbx, %rax
	JMP .main_epilogue
.main_epilogue:
	POPQ %r15
	POPQ %r14
	POPQ %r13
	POPQ %r12
	POPQ %rbx
	MOVQ %rbp, %rsp
	POPQ %rbp
	RET

============= Your Output ===========

27 0
82 1
41 2
124 3
62 4
31 5
94 6
47 7
142 8
71 9
214 10
107 11
322 12
161 13
484 14
242 15
121 16
364 17
182 18
91 19
274 20
137 21
412 22
206 23
103 24
310 25
155 26
466 27
233 28
700 29
350 30
175 31
526 32
263 33
790 34
395 35
1186 36
593 37
1780 38
890 39
445 40
1336 41
668 42
334 43
167 44
502 45
251 46
754 47
377 48
1132 49
566 50
283 51
850 52
425 53
1276 54
638 55
319 56
958 57
479 58
1438 59
719 60
2158 61
1079 62
3238 63
1619 64
4858 65
2429 66
7288 67
3644 68
1822 69
911 70
2734 71
1367 72
4102 73
2051 74
6154 75
3077 76
9232 77
4616 78
2308 79
1154 80
577 81
1732 82
866 83
433 84
1300 85
650 86
325 87
976 88
488 89
244 90
122 91
61 92
184 93
92 94
46 95
23 96
70 97
35 98
106 99
53 100
160 101
80 102
40 103
20 104
10 105
5 106
16 107
8 108
4 109
2 110
1 111

===[good4.bminor Output]===
27 0
82 1
41 2
124 3
62 4
31 5
94 6
47 7
142 8
71 9
214 10
107 11
322 12
161 13
484 14
242 15
121 16
364 17
182 18
91 19
274 20
137 21
412 22
206 23
103 24
310 25
155 26
466 27
233 28
700 29
350 30
175 31
526 32
263 33
790 34
395 35
1186 36
593 37
1780 38
890 39
445 40
1336 41
668 42
334 43
167 44
502 45
251 46
754 47
377 48
1132 49
566 50
283 51
850 52
425 53
1276 54
638 55
319 56
958 57
479 58
1438 59
719 60
2158 61
1079 62
3238 63
1619 64
4858 65
2429 66
7288 67
3644 68
1822 69
911 70
2734 71
1367 72
4102 73
2051 74
6154 75
3077 76
9232 77
4616 78
2308 79
1154 80
577 81
1732 82
866 83
433 84
1300 85
650 86
325 87
976 88
488 89
244 90
122 91
61 92
184 93
92 94
46 95
23 96
70 97
35 98
106 99
53 100
160 101
80 102
40 103
20 104
10 105
5 106
16 107
8 108
4 109
2 110
1 111


return code: 111


===== SUMMARIZED CODEGEN RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 20,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 12,
      "incorrect": 8
    }
  }
}

Codegen Project
--------------------

General Structure (25/25 points)
----------------------------------------------
General structure looks good

Codegen - Functionality (15/15 points)
----------------------------------------------

Generated code:
	- Generated assembly compiles and runs on student machines without added effort (+5)
	- Runs with expected output, exit code, etc (+5)
	- Function calls and stack management working properly (+5)
	

Codegen - Assembly Structure (10/10 points)
----------------------------------------------

Generated code:
	- A file containing at least mostly complete assembly was generated (+5)
	- Loops and conditionals are implemented with jumps and labels (+5)

Student Tests (20/20 points)
------------------------------------------
Very well rounded test cases!

Hidden Tests (12/20 points)
------------------------------------------
Looks like your compiler crashed on a bunch of the hidden inputs

Coding Style (10/10 points)
------------------------------------------
Nice coding style

Extra Credit (10/10 points)
------------------------------------------
Floating point was implemented quite well, nicely done!