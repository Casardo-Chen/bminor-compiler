=====STUDENT TESTS=====
====Good Tests====
===[STUDENT TESTS/good0.bminor Input]===
string
1534
3.4
10e9
'a'
Notre Dame
"\'Notre Dame\'";
>=
===[STUDENT TESTS/good0.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good0.bminor Output]===
STRING string
INTEGER_LITERAL 1534
FLOAT_LITERAL 3.4
FLOAT_LITERAL 10e9
CHARACTER_LITERAL a
IDENTIFIER Notre
IDENTIFIER Dame
STRING_LITERAL 'Notre Dame'
SEMICOLON ;
GTE >=




===[STUDENT TESTS/good1.bminor Input]===
/* tests some more constructs in bminor */
z = -x; // unary negation
x^2; //exponantiotion
//simple test cases
x ^ 2
z != x % 2
z = 5 + 6;
z = 5 * 6;
z = 5 - 6;
z = 5 / 6;
q++;
z--;
z = 7 + 7 - z;
===[STUDENT TESTS/good1.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good1.bminor Output]===
IDENTIFIER z
ASSIGN =
SUBTRACT -
IDENTIFIER x
SEMICOLON ;
IDENTIFIER x
EXPONENTIATION ^
INTEGER_LITERAL 2
SEMICOLON ;
IDENTIFIER x
EXPONENTIATION ^
INTEGER_LITERAL 2
IDENTIFIER z
NOT_EQ !=
IDENTIFIER x
MODULUS %
INTEGER_LITERAL 2
IDENTIFIER z
ASSIGN =
INTEGER_LITERAL 5
PLUS +
INTEGER_LITERAL 6
SEMICOLON ;
IDENTIFIER z
ASSIGN =
INTEGER_LITERAL 5
MULTIPLY *
INTEGER_LITERAL 6
SEMICOLON ;
IDENTIFIER z
ASSIGN =
INTEGER_LITERAL 5
SUBTRACT -
INTEGER_LITERAL 6
SEMICOLON ;
IDENTIFIER z
ASSIGN =
INTEGER_LITERAL 5
DIVIDE /
INTEGER_LITERAL 6
SEMICOLON ;
IDENTIFIER q
INCREMENT ++
SEMICOLON ;
IDENTIFIER z
DECREMENT --
SEMICOLON ;
IDENTIFIER z
ASSIGN =
INTEGER_LITERAL 7
PLUS +
INTEGER_LITERAL 7
SUBTRACT -
IDENTIFIER z
SEMICOLON ;




===[STUDENT TESTS/good2.bminor Input]===
//test some boolean types
bool:boolean = true;
bool:boolean = false;
bool = 5 > 4;
===[STUDENT TESTS/good2.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good2.bminor Output]===
IDENTIFIER bool
COLON :
BOOLEAN boolean
ASSIGN =
TRUE true
SEMICOLON ;
IDENTIFIER bool
COLON :
BOOLEAN boolean
ASSIGN =
FALSE false
SEMICOLON ;
IDENTIFIER bool
ASSIGN =
INTEGER_LITERAL 5
GT >
INTEGER_LITERAL 4
SEMICOLON ;




===[STUDENT TESTS/good3.bminor Input]===
// some more complicated corner cases
z = -(5 * 4);
z = 15 + 5 - 4*3/7;
z = x + (y * 5 - (4 + 20/v) - 15) % 6 + z; //long integer expr
z+++; // these will cause parsing errors
w---;
===[STUDENT TESTS/good3.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good3.bminor Output]===
IDENTIFIER z
ASSIGN =
SUBTRACT -
PARENTHESIS_OPEN (
INTEGER_LITERAL 5
MULTIPLY *
INTEGER_LITERAL 4
PARENTHESIS_CLOSE )
SEMICOLON ;
IDENTIFIER z
ASSIGN =
INTEGER_LITERAL 15
PLUS +
INTEGER_LITERAL 5
SUBTRACT -
INTEGER_LITERAL 4
MULTIPLY *
INTEGER_LITERAL 3
DIVIDE /
INTEGER_LITERAL 7
SEMICOLON ;
IDENTIFIER z
ASSIGN =
IDENTIFIER x
PLUS +
PARENTHESIS_OPEN (
IDENTIFIER y
MULTIPLY *
INTEGER_LITERAL 5
SUBTRACT -
PARENTHESIS_OPEN (
INTEGER_LITERAL 4
PLUS +
INTEGER_LITERAL 20
DIVIDE /
IDENTIFIER v
PARENTHESIS_CLOSE )
SUBTRACT -
INTEGER_LITERAL 15
PARENTHESIS_CLOSE )
MODULUS %
INTEGER_LITERAL 6
PLUS +
IDENTIFIER z
SEMICOLON ;
IDENTIFIER z
INCREMENT ++
PLUS +
SEMICOLON ;
IDENTIFIER w
DECREMENT --
SUBTRACT -
SEMICOLON ;




===[STUDENT TESTS/good5.bminor Input]===
//test arrays
f:array [5]integer = { 1, 2, 3, 4, 5};
f:array[5]char = {'a', 'b', 'c', 'd', 'e'};
f:array[5] boolean = {false, false, true, true, true};
f:array [] 	string = {"this", "i", "s", "a,", "test", "."};
===[STUDENT TESTS/good5.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good5.bminor Output]===
IDENTIFIER f
COLON :
ARRAY array
BRACKET_OPEN [
INTEGER_LITERAL 5
BRACKET_OPEN ]
INTEGER integer
ASSIGN =
BRACE_OPEN {
INTEGER_LITERAL 1
COMMA ,
INTEGER_LITERAL 2
COMMA ,
INTEGER_LITERAL 3
COMMA ,
INTEGER_LITERAL 4
COMMA ,
INTEGER_LITERAL 5
BRACE_CLOSE }
SEMICOLON ;
IDENTIFIER f
COLON :
ARRAY array
BRACKET_OPEN [
INTEGER_LITERAL 5
BRACKET_OPEN ]
CHAR char
ASSIGN =
BRACE_OPEN {
CHARACTER_LITERAL a
COMMA ,
CHARACTER_LITERAL b
COMMA ,
CHARACTER_LITERAL c
COMMA ,
CHARACTER_LITERAL d
COMMA ,
CHARACTER_LITERAL e
BRACE_CLOSE }
SEMICOLON ;
IDENTIFIER f
COLON :
ARRAY array
BRACKET_OPEN [
INTEGER_LITERAL 5
BRACKET_OPEN ]
BOOLEAN boolean
ASSIGN =
BRACE_OPEN {
FALSE false
COMMA ,
FALSE false
COMMA ,
TRUE true
COMMA ,
TRUE true
COMMA ,
TRUE true
BRACE_CLOSE }
SEMICOLON ;
IDENTIFIER f
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
STRING string
ASSIGN =
BRACE_OPEN {
STRING_LITERAL this
COMMA ,
STRING_LITERAL i
COMMA ,
STRING_LITERAL s
COMMA ,
STRING_LITERAL a,
COMMA ,
STRING_LITERAL test
COMMA ,
STRING_LITERAL .
BRACE_CLOSE }
SEMICOLON ;




===[STUDENT TESTS/good6.bminor Input]===
// test comparotors and boolean logic
if ( a >= 5 )
{
	print "a >= 5";
}
if( a > 5 )
{
	print "a > 5";
}
if( a <= 5 )
{
	print "a <= 5";
}
if( a < 5 )
{
	print "a < 5";
}
if( a == 5 )
{
	print "a == 5";
}
if( a != 5 )
{
	print "a != 5";
}
a = 5; // test assigment
if (a || b)
{
	print " a || b is true";
}
if (a && b)
{
	print " a && b is true";
}
===[STUDENT TESTS/good6.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good6.bminor Output]===
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
GTE >=
INTEGER_LITERAL 5
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL a >= 5
SEMICOLON ;
BRACE_CLOSE }
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
GT >
INTEGER_LITERAL 5
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL a > 5
SEMICOLON ;
BRACE_CLOSE }
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
LTE <=
INTEGER_LITERAL 5
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL a <= 5
SEMICOLON ;
BRACE_CLOSE }
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
LT <
INTEGER_LITERAL 5
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL a < 5
SEMICOLON ;
BRACE_CLOSE }
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
EQ ==
INTEGER_LITERAL 5
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL a == 5
SEMICOLON ;
BRACE_CLOSE }
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
NOT_EQ !=
INTEGER_LITERAL 5
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL a != 5
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER a
ASSIGN =
INTEGER_LITERAL 5
SEMICOLON ;
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
OR ||
IDENTIFIER b
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL  a || b is true
SEMICOLON ;
BRACE_CLOSE }
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
AND &&
IDENTIFIER b
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL  a && b is true
SEMICOLON ;
BRACE_CLOSE }




===[STUDENT TESTS/good7.bminor Input]===
intFunction: function integer(intVar:integer, boolVar: boolean)
{
	if(boolVar)
	{
		intVar = intVar * 2;
	}
	return intVar;
}
// finds the largest value in the array
getLargest: function integer(intArrVar:array [] integer, int len) =
{
	largest:integer = 0;
	x:integer;
	for(x = 0; x < len; x++)
	{
		if(intArrVar[x] > largest)
		{
			largest = intArrVar[x];
		}
	}
	return largest;
		
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	b:array [10] integer = {0,1,2,3,4,5};
	b[4] = 6;
	i:integer;
	z:integer = intFunction(i, true);
	print intArrFunction(v, z);
}
===[STUDENT TESTS/good7.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good7.bminor Output]===
IDENTIFIER intFunction
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER intVar
COLON :
INTEGER integer
COMMA ,
IDENTIFIER boolVar
COLON :
BOOLEAN boolean
PARENTHESIS_CLOSE )
BRACE_OPEN {
IF if
PARENTHESIS_OPEN (
IDENTIFIER boolVar
PARENTHESIS_CLOSE )
BRACE_OPEN {
IDENTIFIER intVar
ASSIGN =
IDENTIFIER intVar
MULTIPLY *
INTEGER_LITERAL 2
SEMICOLON ;
BRACE_CLOSE }
RETURN return
IDENTIFIER intVar
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER getLargest
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER intArrVar
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
INTEGER integer
COMMA ,
IDENTIFIER int
IDENTIFIER len
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
IDENTIFIER largest
COLON :
INTEGER integer
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER x
COLON :
INTEGER integer
SEMICOLON ;
FOR for
PARENTHESIS_OPEN (
IDENTIFIER x
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER x
LT <
IDENTIFIER len
SEMICOLON ;
IDENTIFIER x
INCREMENT ++
PARENTHESIS_CLOSE )
BRACE_OPEN {
IF if
PARENTHESIS_OPEN (
IDENTIFIER intArrVar
BRACKET_OPEN [
IDENTIFIER x
BRACKET_OPEN ]
GT >
IDENTIFIER largest
PARENTHESIS_CLOSE )
BRACE_OPEN {
IDENTIFIER largest
ASSIGN =
IDENTIFIER intArrVar
BRACKET_OPEN [
IDENTIFIER x
BRACKET_OPEN ]
SEMICOLON ;
BRACE_CLOSE }
BRACE_CLOSE }
RETURN return
IDENTIFIER largest
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER main
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER argc
COLON :
INTEGER integer
COMMA ,
IDENTIFIER argv
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
STRING string
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
IDENTIFIER b
COLON :
ARRAY array
BRACKET_OPEN [
INTEGER_LITERAL 10
BRACKET_OPEN ]
INTEGER integer
ASSIGN =
BRACE_OPEN {
INTEGER_LITERAL 0
COMMA ,
INTEGER_LITERAL 1
COMMA ,
INTEGER_LITERAL 2
COMMA ,
INTEGER_LITERAL 3
COMMA ,
INTEGER_LITERAL 4
COMMA ,
INTEGER_LITERAL 5
BRACE_CLOSE }
SEMICOLON ;
IDENTIFIER b
BRACKET_OPEN [
INTEGER_LITERAL 4
BRACKET_OPEN ]
ASSIGN =
INTEGER_LITERAL 6
SEMICOLON ;
IDENTIFIER i
COLON :
INTEGER integer
SEMICOLON ;
IDENTIFIER z
COLON :
INTEGER integer
ASSIGN =
IDENTIFIER intFunction
PARENTHESIS_OPEN (
IDENTIFIER i
COMMA ,
TRUE true
PARENTHESIS_CLOSE )
SEMICOLON ;
PRINT print
IDENTIFIER intArrFunction
PARENTHESIS_OPEN (
IDENTIFIER v
COMMA ,
IDENTIFIER z
PARENTHESIS_CLOSE )
SEMICOLON ;
BRACE_CLOSE }




===[STUDENT TESTS/good8.bminor Input]===
main: function integer ( argc: integer, argv: array [] string ) =
{
}
boolFunction: function boolean(intVar:integer) =
{
	return intVar > 5;
}
intFunction: function integer(integer n) =
{
	total:integer = 0;
	int count;
	for(count = 0; count < n+1; count++)
	{
		total = total + count;
	
}
===[STUDENT TESTS/good8.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good8.bminor Output]===
IDENTIFIER main
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER argc
COLON :
INTEGER integer
COMMA ,
IDENTIFIER argv
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
STRING string
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
BRACE_CLOSE }
IDENTIFIER boolFunction
COLON :
FUNCTION function
BOOLEAN boolean
PARENTHESIS_OPEN (
IDENTIFIER intVar
COLON :
INTEGER integer
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
RETURN return
IDENTIFIER intVar
GT >
INTEGER_LITERAL 5
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER intFunction
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
INTEGER integer
IDENTIFIER n
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
IDENTIFIER total
COLON :
INTEGER integer
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER int
IDENTIFIER count
SEMICOLON ;
FOR for
PARENTHESIS_OPEN (
IDENTIFIER count
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER count
LT <
IDENTIFIER n
INTEGER_LITERAL +1
SEMICOLON ;
IDENTIFIER count
INCREMENT ++
PARENTHESIS_CLOSE )
BRACE_OPEN {
IDENTIFIER total
ASSIGN =
IDENTIFIER total
PLUS +
IDENTIFIER count
SEMICOLON ;
BRACE_CLOSE }




===[STUDENT TESTS/good9.bminor Input]===
// just runs all basic tokens
//
/* comment */
array 
boolean 
char 
else 
false 
for 
function 
if 
integer 
print 
return 
string 
true
void
while
:
;
,
[
]
{
}
(
)
=
^
+
-
++
--
*
/
%
==
>=
<=
<
>
!=
a
ab
ab3
ab3a
12314
1
12
123
'A'
""
"a"
"aa"
===[STUDENT TESTS/good9.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good9.bminor Output]===
ARRAY array
BOOLEAN boolean
CHAR char
ELSE else
FALSE false
FOR for
FUNCTION function
IF if
INTEGER integer
PRINT print
RETURN return
STRING string
TRUE true
VOID void
WHILE while
COLON :
SEMICOLON ;
COMMA ,
BRACKET_OPEN [
BRACKET_OPEN ]
BRACE_OPEN {
BRACE_CLOSE }
PARENTHESIS_OPEN (
PARENTHESIS_CLOSE )
ASSIGN =
EXPONENTIATION ^
PLUS +
SUBTRACT -
INCREMENT ++
DECREMENT --
MULTIPLY *
DIVIDE /
MODULUS %
EQ ==
GTE >=
LTE <=
LT <
GT >
NOT_EQ !=
IDENTIFIER a
IDENTIFIER ab
IDENTIFIER ab3
IDENTIFIER ab3a
INTEGER_LITERAL 12314
INTEGER_LITERAL 1
INTEGER_LITERAL 12
INTEGER_LITERAL 123
CHARACTER_LITERAL A
STRING_LITERAL 
STRING_LITERAL a
STRING_LITERAL aa




====Bad Tests====
===[STUDENT TESTS/bad0.bminor Input]===
@
#
&
|
\
===[STUDENT TESTS/bad0.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad0.bminor Output]===
scan error: @ is not a valid character




===[STUDENT TESTS/bad1.bminor Input]===

"""
===[STUDENT TESTS/bad1.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad1.bminor Output]===
STRING_LITERAL 
scan error: " is not a valid character




===[STUDENT TESTS/bad2.bminor Input]===
"012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"
===[STUDENT TESTS/bad2.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad2.bminor Output]===
Error: length exceed 255 characters
scan error: "012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" is not a valid character




===[STUDENT TESTS/bad3.bminor Input]===
minus#44
===[STUDENT TESTS/bad3.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad3.bminor Output]===
IDENTIFIER minus
scan error: # is not a valid character




===[STUDENT TESTS/bad4.bminor Input]===
// strings
str:string = "";

str:string = "hello this is a string!";
str:string = "hello this is \1 a string!";

str:string = "11234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567891123456789112345678911234567"// less then 160 characters 


===[STUDENT TESTS/bad4.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad4.bminor Output]===
IDENTIFIER str
COLON :
STRING string
ASSIGN =
STRING_LITERAL 
SEMICOLON ;
IDENTIFIER str
COLON :
STRING string
ASSIGN =
STRING_LITERAL hello this is a string!
SEMICOLON ;
IDENTIFIER str
COLON :
STRING string
ASSIGN =
Error: Invalid escape sequence
scan error: "hello this is \1 a string!" is not a valid character




===[STUDENT TESTS/bad5.bminor Input]===
// basic data types


character:	 	char = 'c';
character: char = '\n';
character = '\6';
character = '\c'
character = '\t'
===[STUDENT TESTS/bad5.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad5.bminor Output]===
IDENTIFIER character
COLON :
CHAR char
ASSIGN =
CHARACTER_LITERAL c
SEMICOLON ;
IDENTIFIER character
COLON :
CHAR char
ASSIGN =
CHARACTER_LITERAL 

SEMICOLON ;
IDENTIFIER character
ASSIGN =
Error: Invalid escape sequence
scan error: "\6" is not a valid character




===[STUDENT TESTS/bad6.bminor Input]===
'ca'
===[STUDENT TESTS/bad6.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad6.bminor Output]===
scan error: ' is not a valid character




===[STUDENT TESTS/bad7.bminor Input]===
// unmatched comment throws error 
/* This is a comment.
===[STUDENT TESTS/bad7.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad7.bminor Output]===
DIVIDE /
MULTIPLY *
IDENTIFIER This
IDENTIFIER is
IDENTIFIER a
IDENTIFIER comment
scan error: . is not a valid character




===[STUDENT TESTS/bad8.bminor Input]===
$minus
===[STUDENT TESTS/bad8.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad8.bminor Output]===
scan error: $ is not a valid character




===[STUDENT TESTS/bad9.bminor Input]===
"In \0xfg Southwerk at the tabard as I lay"
===[STUDENT TESTS/bad9.bminor Status]===
return code: 1
Test passed successfully!

===[STUDENT TESTS/bad9.bminor Output]===
Error: Invalid hexadecimal escape sequence
scan error: "In \0xfg Southwerk at the tabard as I lay" is not a valid character




=====HIDDEN TESTS=====
====Good Tests====
===[HIDDEN TESTS/good11.bminor Input]===
// some more complicated corner cases
z = -(5 * 4);
z = 15 + 5 - 4*3/7;
z = x + (y * 5 - (4 + 20/v) - 15) % 6 + z; //long integer expr
z+++; // these will cause parsing errors
w---;


===[HIDDEN TESTS/good11.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good11.bminor Output]===
IDENTIFIER z
ASSIGN =
SUBTRACT -
PARENTHESIS_OPEN (
INTEGER_LITERAL 5
MULTIPLY *
INTEGER_LITERAL 4
PARENTHESIS_CLOSE )
SEMICOLON ;
IDENTIFIER z
ASSIGN =
INTEGER_LITERAL 15
PLUS +
INTEGER_LITERAL 5
SUBTRACT -
INTEGER_LITERAL 4
MULTIPLY *
INTEGER_LITERAL 3
DIVIDE /
INTEGER_LITERAL 7
SEMICOLON ;
IDENTIFIER z
ASSIGN =
IDENTIFIER x
PLUS +
PARENTHESIS_OPEN (
IDENTIFIER y
MULTIPLY *
INTEGER_LITERAL 5
SUBTRACT -
PARENTHESIS_OPEN (
INTEGER_LITERAL 4
PLUS +
INTEGER_LITERAL 20
DIVIDE /
IDENTIFIER v
PARENTHESIS_CLOSE )
SUBTRACT -
INTEGER_LITERAL 15
PARENTHESIS_CLOSE )
MODULUS %
INTEGER_LITERAL 6
PLUS +
IDENTIFIER z
SEMICOLON ;
IDENTIFIER z
INCREMENT ++
PLUS +
SEMICOLON ;
IDENTIFIER w
DECREMENT --
SUBTRACT -
SEMICOLON ;




===[HIDDEN TESTS/good12.bminor Input]===
//tests the for/print keyword and while keyword
x:integer;
for(x = 0; x < 5; x++)
{
	print "counting: ", x;
}
a:integer = 0;
while(a > 0)
{
	a--;
}



===[HIDDEN TESTS/good12.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good12.bminor Output]===
IDENTIFIER x
COLON :
INTEGER integer
SEMICOLON ;
FOR for
PARENTHESIS_OPEN (
IDENTIFIER x
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER x
LT <
INTEGER_LITERAL 5
SEMICOLON ;
IDENTIFIER x
INCREMENT ++
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL counting: 
COMMA ,
IDENTIFIER x
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER a
COLON :
INTEGER integer
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
WHILE while
PARENTHESIS_OPEN (
IDENTIFIER a
GT >
INTEGER_LITERAL 0
PARENTHESIS_CLOSE )
BRACE_OPEN {
IDENTIFIER a
DECREMENT --
SEMICOLON ;
BRACE_CLOSE }




===[HIDDEN TESTS/good13.bminor Input]===
//test some odd identifier names
ident55
ident55_
ident__55__
thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt = 7
variable_names_may_contain_underscores_
_variables_can_start_with_an_underscore_67
7minus5 

===[HIDDEN TESTS/good13.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good13.bminor Output]===
IDENTIFIER ident55
IDENTIFIER ident55_
IDENTIFIER ident__55__
IDENTIFIER thisIsAReallyReallyLongIdentifierNameThatHasTonsOfLettersInIt
ASSIGN =
INTEGER_LITERAL 7
IDENTIFIER variable_names_may_contain_underscores_
IDENTIFIER _variables_can_start_with_an_underscore_67
INTEGER_LITERAL 7
IDENTIFIER minus5




===[HIDDEN TESTS/good14.bminor Input]===
main: function integer ( argc: integer, argv: array [] string ) =
{
}
boolFunction: function boolean(intVar:integer) =
{
	return intVar > 5;
}
intFunction: function integer(integer n) =
{
	total:integer = 0;
	int count;
	for(count = 0; count < n+1; count++)
	{
		total = total + count;
	
}


===[HIDDEN TESTS/good14.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good14.bminor Output]===
IDENTIFIER main
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER argc
COLON :
INTEGER integer
COMMA ,
IDENTIFIER argv
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
STRING string
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
BRACE_CLOSE }
IDENTIFIER boolFunction
COLON :
FUNCTION function
BOOLEAN boolean
PARENTHESIS_OPEN (
IDENTIFIER intVar
COLON :
INTEGER integer
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
RETURN return
IDENTIFIER intVar
GT >
INTEGER_LITERAL 5
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER intFunction
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
INTEGER integer
IDENTIFIER n
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
IDENTIFIER total
COLON :
INTEGER integer
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER int
IDENTIFIER count
SEMICOLON ;
FOR for
PARENTHESIS_OPEN (
IDENTIFIER count
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER count
LT <
IDENTIFIER n
INTEGER_LITERAL +1
SEMICOLON ;
IDENTIFIER count
INCREMENT ++
PARENTHESIS_CLOSE )
BRACE_OPEN {
IDENTIFIER total
ASSIGN =
IDENTIFIER total
PLUS +
IDENTIFIER count
SEMICOLON ;
BRACE_CLOSE }




===[HIDDEN TESTS/good15.bminor Input]===
intFunction: function integer(intVar:integer, boolVar: boolean)
{
	if(boolVar)
	{
		intVar = intVar * 2;
	}
	return intVar;
}
// finds the largest value in the array
getLargest: function integer(intArrVar:array [] integer, int len) =
{
	largest:integer = 0;
	x:integer;
	for(x = 0; x < len; x++)
	{
		if(intArrVar[x] > largest)
		{
			largest = intArrVar[x];
		}
	}
	return largest;
		
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	b:array [10] integer = {0,1,2,3,4,5};
	b[4] = 6;
	i:integer;
	z:integer = intFunction(i, true);
	print intArrFunction(v, z);
}

===[HIDDEN TESTS/good15.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good15.bminor Output]===
IDENTIFIER intFunction
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER intVar
COLON :
INTEGER integer
COMMA ,
IDENTIFIER boolVar
COLON :
BOOLEAN boolean
PARENTHESIS_CLOSE )
BRACE_OPEN {
IF if
PARENTHESIS_OPEN (
IDENTIFIER boolVar
PARENTHESIS_CLOSE )
BRACE_OPEN {
IDENTIFIER intVar
ASSIGN =
IDENTIFIER intVar
MULTIPLY *
INTEGER_LITERAL 2
SEMICOLON ;
BRACE_CLOSE }
RETURN return
IDENTIFIER intVar
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER getLargest
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER intArrVar
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
INTEGER integer
COMMA ,
IDENTIFIER int
IDENTIFIER len
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
IDENTIFIER largest
COLON :
INTEGER integer
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER x
COLON :
INTEGER integer
SEMICOLON ;
FOR for
PARENTHESIS_OPEN (
IDENTIFIER x
ASSIGN =
INTEGER_LITERAL 0
SEMICOLON ;
IDENTIFIER x
LT <
IDENTIFIER len
SEMICOLON ;
IDENTIFIER x
INCREMENT ++
PARENTHESIS_CLOSE )
BRACE_OPEN {
IF if
PARENTHESIS_OPEN (
IDENTIFIER intArrVar
BRACKET_OPEN [
IDENTIFIER x
BRACKET_OPEN ]
GT >
IDENTIFIER largest
PARENTHESIS_CLOSE )
BRACE_OPEN {
IDENTIFIER largest
ASSIGN =
IDENTIFIER intArrVar
BRACKET_OPEN [
IDENTIFIER x
BRACKET_OPEN ]
SEMICOLON ;
BRACE_CLOSE }
BRACE_CLOSE }
RETURN return
IDENTIFIER largest
SEMICOLON ;
BRACE_CLOSE }
IDENTIFIER main
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER argc
COLON :
INTEGER integer
COMMA ,
IDENTIFIER argv
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
STRING string
PARENTHESIS_CLOSE )
ASSIGN =
BRACE_OPEN {
IDENTIFIER b
COLON :
ARRAY array
BRACKET_OPEN [
INTEGER_LITERAL 10
BRACKET_OPEN ]
INTEGER integer
ASSIGN =
BRACE_OPEN {
INTEGER_LITERAL 0
COMMA ,
INTEGER_LITERAL 1
COMMA ,
INTEGER_LITERAL 2
COMMA ,
INTEGER_LITERAL 3
COMMA ,
INTEGER_LITERAL 4
COMMA ,
INTEGER_LITERAL 5
BRACE_CLOSE }
SEMICOLON ;
IDENTIFIER b
BRACKET_OPEN [
INTEGER_LITERAL 4
BRACKET_OPEN ]
ASSIGN =
INTEGER_LITERAL 6
SEMICOLON ;
IDENTIFIER i
COLON :
INTEGER integer
SEMICOLON ;
IDENTIFIER z
COLON :
INTEGER integer
ASSIGN =
IDENTIFIER intFunction
PARENTHESIS_OPEN (
IDENTIFIER i
COMMA ,
TRUE true
PARENTHESIS_CLOSE )
SEMICOLON ;
PRINT print
IDENTIFIER intArrFunction
PARENTHESIS_OPEN (
IDENTIFIER v
COMMA ,
IDENTIFIER z
PARENTHESIS_CLOSE )
SEMICOLON ;
BRACE_CLOSE }




===[HIDDEN TESTS/good1.bminor Input]===
// Easy comment
/* Easy comment */

===[HIDDEN TESTS/good1.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good1.bminor Output]===




===[HIDDEN TESTS/good10.bminor Input]===
// Modulus operator
15%3

// Exponentiation operator
2^6

// Negation
-value

// Postincrement and postdecrement
number++;

number--;

===[HIDDEN TESTS/good10.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good10.bminor Output]===
INTEGER_LITERAL 15
MODULUS %
INTEGER_LITERAL 3
INTEGER_LITERAL 2
EXPONENTIATION ^
INTEGER_LITERAL 6
SUBTRACT -
IDENTIFIER value
IDENTIFIER number
INCREMENT ++
SEMICOLON ;
IDENTIFIER number
DECREMENT --
SEMICOLON ;




===[HIDDEN TESTS/good2.bminor Input]===
////* Harder comment ***/
/******************/
/*
This one works too.
*/
/***************
Also a good comment.
****************/
// comment // comment // comment


===[HIDDEN TESTS/good2.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good2.bminor Output]===




===[HIDDEN TESTS/good3.bminor Input]===
// Identifiers
CamelCase
lower_case
skiddo23
B4UFLY
i
x15


===[HIDDEN TESTS/good3.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good3.bminor Output]===
IDENTIFIER CamelCase
IDENTIFIER lower_case
IDENTIFIER skiddo23
IDENTIFIER B4UFLY
IDENTIFIER i
IDENTIFIER x15




===[HIDDEN TESTS/good4.bminor Input]===
// Equality Operators
== != <= < > >=

===[HIDDEN TESTS/good4.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good4.bminor Output]===
EQ ==
NOT_EQ !=
LTE <=
LT <
GT >
GTE >=




===[HIDDEN TESTS/good5.bminor Input]===
// Various bits of punctuation
, : ; ( ) [ ] { }


===[HIDDEN TESTS/good5.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good5.bminor Output]===
COMMA ,
COLON :
SEMICOLON ;
PARENTHESIS_OPEN (
PARENTHESIS_CLOSE )
BRACKET_OPEN [
BRACKET_OPEN ]
BRACE_OPEN {
BRACE_CLOSE }




===[HIDDEN TESTS/good6.bminor Input]===
// Complete function prototype
main: function integer ( argc: integer, argv: array [] string );


===[HIDDEN TESTS/good6.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good6.bminor Output]===
IDENTIFIER main
COLON :
FUNCTION function
INTEGER integer
PARENTHESIS_OPEN (
IDENTIFIER argc
COLON :
INTEGER integer
COMMA ,
IDENTIFIER argv
COLON :
ARRAY array
BRACKET_OPEN [
BRACKET_OPEN ]
STRING string
PARENTHESIS_CLOSE )
SEMICOLON ;




===[HIDDEN TESTS/good7.bminor Input]===
// Nested statements
if( x<15 ) {
    print "small";
} else {
    print "large!";
}


===[HIDDEN TESTS/good7.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good7.bminor Output]===
IF if
PARENTHESIS_OPEN (
IDENTIFIER x
LT <
INTEGER_LITERAL 15
PARENTHESIS_CLOSE )
BRACE_OPEN {
PRINT print
STRING_LITERAL small
SEMICOLON ;
BRACE_CLOSE }
ELSE else
BRACE_OPEN {
PRINT print
STRING_LITERAL large!
SEMICOLON ;
BRACE_CLOSE }




===[HIDDEN TESTS/good8.bminor Input]===
// Valid integers
0
1024
-512
+256
// valid floats
1.2
0.45
.67
12e10
+1.2
-1.2
1.2e+1
1.2e-1
+1.2e+1
+1.2e-1
-1.2e+1
-1.2e-1

===[HIDDEN TESTS/good8.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good8.bminor Output]===
INTEGER_LITERAL 0
INTEGER_LITERAL 1024
INTEGER_LITERAL -512
INTEGER_LITERAL +256
FLOAT_LITERAL 1.2
FLOAT_LITERAL 0.45
FLOAT_LITERAL .67
FLOAT_LITERAL 12e10
FLOAT_LITERAL +1.2
FLOAT_LITERAL -1.2
FLOAT_LITERAL 1.2e+1
FLOAT_LITERAL 1.2e-1
FLOAT_LITERAL +1.2e+1
FLOAT_LITERAL +1.2e-1
FLOAT_LITERAL -1.2e+1
FLOAT_LITERAL -1.2e-1




===[HIDDEN TESTS/good9.bminor Input]===
// Type Keywords
array
boolean
char
string
void
integer
float

===[HIDDEN TESTS/good9.bminor Status]===
return code: 0
Test passed successfully!

===[HIDDEN TESTS/good9.bminor Output]===
ARRAY array
BOOLEAN boolean
CHAR char
STRING string
VOID void
INTEGER integer
IDENTIFIER float




====Bad Tests====
===[HIDDEN TESTS/bad11.bminor Input]===
/*
A string should not contain a literal newline,
but use backslash-n instead.
*/

"invalid

string"

===[HIDDEN TESTS/bad11.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad11.bminor Output]===
scan error: " is not a valid character




===[HIDDEN TESTS/bad12.bminor Input]===
'ca'

===[HIDDEN TESTS/bad12.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad12.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad13.bminor Input]===
''

===[HIDDEN TESTS/bad13.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad13.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad14.bminor Input]===
'\ac'

===[HIDDEN TESTS/bad14.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad14.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad15.bminor Input]===
'

===[HIDDEN TESTS/bad15.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad15.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad1.bminor Input]===
"unmatched string""

===[HIDDEN TESTS/bad1.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad1.bminor Output]===
STRING_LITERAL unmatched string
scan error: " is not a valid character




===[HIDDEN TESTS/bad10.bminor Input]===
#compilers // No hashtags in B-minor

===[HIDDEN TESTS/bad10.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad10.bminor Output]===
scan error: # is not a valid character




===[HIDDEN TESTS/bad2.bminor Input]===
"unterminated \"


===[HIDDEN TESTS/bad2.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad2.bminor Output]===
Error: Unclosed double quote
scan error: "unterminated \" is not a valid character




===[HIDDEN TESTS/bad3.bminor Input]===
never started"






===[HIDDEN TESTS/bad3.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad3.bminor Output]===
IDENTIFIER never
IDENTIFIER started
scan error: " is not a valid character




===[HIDDEN TESTS/bad4.bminor Input]===
'character?' // Character too long.

===[HIDDEN TESTS/bad4.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad4.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad5.bminor Input]===
'' // Empty character not allowed.

===[HIDDEN TESTS/bad5.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad5.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad6.bminor Input]===
~tilde // Invalid symbol

===[HIDDEN TESTS/bad6.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad6.bminor Output]===
scan error: ~ is not a valid character




===[HIDDEN TESTS/bad7.bminor Input]===
/* Is this a valid comment */ @ */


===[HIDDEN TESTS/bad7.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad7.bminor Output]===
scan error: @ is not a valid character




===[HIDDEN TESTS/bad8.bminor Input]===
"\0xGG" // invalid escape sequence

===[HIDDEN TESTS/bad8.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad8.bminor Output]===
Error: Invalid hexadecimal escape sequence
scan error: "\0xGG" is not a valid character




===[HIDDEN TESTS/bad9.bminor Input]===
minus#44

===[HIDDEN TESTS/bad9.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad9.bminor Output]===
IDENTIFIER minus
scan error: # is not a valid character




===[HIDDEN TESTS/bad16.bminor Input]===
@
#
&
|
\

===[HIDDEN TESTS/bad16.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad16.bminor Output]===
scan error: @ is not a valid character




===[HIDDEN TESTS/bad17.bminor Input]===
// unmatched comment throws error 
/* This is a comment.








===[HIDDEN TESTS/bad17.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad17.bminor Output]===
DIVIDE /
MULTIPLY *
IDENTIFIER This
IDENTIFIER is
IDENTIFIER a
IDENTIFIER comment
scan error: . is not a valid character




===[HIDDEN TESTS/bad18.bminor Input]===
// basic data types
" the quote is unmatched







===[HIDDEN TESTS/bad18.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad18.bminor Output]===
scan error: " is not a valid character




===[HIDDEN TESTS/bad19.bminor Input]===
// floating point mistake
5..6..0..5..0;

===[HIDDEN TESTS/bad19.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad19.bminor Output]===
INTEGER_LITERAL 5
scan error: . is not a valid character




===[HIDDEN TESTS/bad20.bminor Input]===
// test comparotors and boolean logic
if (a | b)
{
	print " a || b is true";
}
if (a & b)// must had 2 &&
{
	print " a || b is true";
}

===[HIDDEN TESTS/bad20.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad20.bminor Output]===
IF if
PARENTHESIS_OPEN (
IDENTIFIER a
scan error: | is not a valid character




===[HIDDEN TESTS/bad21.bminor Input]===

"""


===[HIDDEN TESTS/bad21.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad21.bminor Output]===
STRING_LITERAL 
scan error: " is not a valid character




===[HIDDEN TESTS/bad22.bminor Input]===
"012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890"


===[HIDDEN TESTS/bad22.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad22.bminor Output]===
Error: length exceed 255 characters
scan error: "012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789010123456789012345678901012345678901234567890101234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890" is not a valid character




===[HIDDEN TESTS/bad23.bminor Input]===
$minus

===[HIDDEN TESTS/bad23.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad23.bminor Output]===
scan error: $ is not a valid character




===[HIDDEN TESTS/bad25.bminor Input]===
// invalid character
'😋'

===[HIDDEN TESTS/bad25.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad25.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad26.bminor Input]===
/*
A string should not contain a literal newline,
but use backslash-n instead.
*/

"invalid

string"

===[HIDDEN TESTS/bad26.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad26.bminor Output]===
scan error: " is not a valid character




===[HIDDEN TESTS/bad27.bminor Input]===
'''

===[HIDDEN TESTS/bad27.bminor Status]===
return code: 0
TEST NOT PASSED

===[HIDDEN TESTS/bad27.bminor Output]===
CHARACTER_LITERAL '




===[HIDDEN TESTS/bad28.bminor Input]===
"'"'"

===[HIDDEN TESTS/bad28.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad28.bminor Output]===
STRING_LITERAL '
scan error: ' is not a valid character




===[HIDDEN TESTS/bad29.bminor Input]===
'\t\e\s\t\ \s\t\r\i\n\g'

===[HIDDEN TESTS/bad29.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad29.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad30.bminor Input]===
'\0x12\0x34'

===[HIDDEN TESTS/bad30.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad30.bminor Output]===
scan error: ' is not a valid character




===[HIDDEN TESTS/bad0.bminor Input]===
!@#$*(!&%!@)#(@!+)!@*!@)*$!@_)(%!@_%(*!

===[HIDDEN TESTS/bad0.bminor Status]===
return code: 1
Test passed successfully!

===[HIDDEN TESTS/bad0.bminor Output]===
NOT !
scan error: @ is not a valid character




===== SUMMARIZED SCANNER RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 9,
      "incorrect": 0
    },
    "Bad": {
      "correct": 10,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 15,
      "incorrect": 0
    },
    "Bad": {
      "correct": 29,
      "incorrect": 1
    }
  }
}
Scanner Project Grade
    ---------------------------------

    General Structure (35/35 points)
    ----------------------------------------------
    I would take another pass at your main function and make sure that its readable and can be easily extended. It might get really messy towards the end of the semester if no preventative care is taken.

    Student Tests (19/20 points)
    ------------------------------------------
    -1 point for not proving 10 good tests

    Hidden Tests (44/45 points)
    ------------------------------------------
    Missed a test case with an unescaped single quote in a char

    Coding Style (10/10 points)
    ------------------------------------------
    The whitespace in the flex file is really helpful for code readability. It made understanding your code much easier.