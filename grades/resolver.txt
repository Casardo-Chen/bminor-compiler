=====STUDENT TESTS=====
====Good Tests====
===[good0.bminor Input]===
//some variable usages
x:integer;
y:integer;
z:integer;
arr:array[5] array[5] integer;
str: string = "hello world";
fxn : function  integer () =
{
	arr[3][2] = 5;
	x = arr[2][3];
	x++;
	return z;
	c:char = str[0];
} 
===[good0.bminor Output]===
Success!

arr resolves to global arr
x resolves to global x
arr resolves to global arr
x resolves to global x
z resolves to global z
str resolves to global str


return code: 0


===[good1.bminor Input]===
/* Assign integer expression to local variable/ typechecking with function call. */

x: integer = 5;
y: integer = 10;

main: function void ()=
{
	x: integer = y * 10 + 15 - 4;
}
===[good1.bminor Output]===
Success!

y resolves to global y


return code: 0


===[good2.bminor Input]===
// Declarations in nested scopes

f: function void (x: integer, y: integer) = {
    print x;
    print y;
    {
        x: integer;
        print x;
    }
    x: integer;
    y: integer;
    print x;
    print y;
}
===[good2.bminor Output]===
Success!

x resolves to param 0
y resolves to param 1
x resolves to local 2
x resolves to local 3
y resolves to local 4


return code: 0


===[good3.bminor Input]===
foo: function void();
foo: function void();
===[good3.bminor Output]===
Success!



return code: 0


===[good4.bminor Input]===
// empty
===[good4.bminor Output]===
Success!



return code: 0


===[good5.bminor Input]===
/*
This program displays a square bouncing around on the screen.
Click to reset the square in a new place.
It makes use of the (included) C gfx library and the standard C library,
and exercises, loops, comparisons, and logical operators.
*/

/* These are the functions in the gfx library. */
gfx_open: function void ( width: integer, height: integer, title:string );
gfx_point: function void ( x: integer, y: integer );
gfx_line: function void ( x1:integer, y1:integer, x2:integer, y2:integer );
gfx_color: function void ( red:integer, green: integer, blue:integer );
gfx_clear: function void ();
gfx_clear_color: function void ( red:integer, green: integer, blue:integer );
gfx_wait: function char ();
gfx_xpos: function integer ();
gfx_ypos: function integer ();
gfx_xsize: function integer ();
gfx_ysize: function integer ();
gfx_event_waiting: function boolean ();
gfx_flush: function integer ();

/* These functions come from the C standard library. */

usleep: function void ( usecs: integer );
rand: function integer();

draw_box: function void ( x: integer, y:integer, size: integer ) =
{
	gfx_color(255,255,255);
	gfx_line(x,y,x+size,y);
	gfx_line(x+size,y,x+size,y+size);
	gfx_line(x+size,y+size,x,y+size);
	gfx_line(x,y+size,x,y);
}

/*
Note that the precision multiplier indicates fixed-point
match to keep track of sub-pixel position and velocity for the box.
*/

main: function integer () =
{
	precision: integer = 100;

	xsize: integer = 500; // pixels
	ysize: integer = 500; // pixels 

	x: integer = precision * xsize / 2;
	y: integer = precision * ysize / 2;

	vx: integer = precision * 3;
	vy: integer = precision * -5 ;

	deltat: integer = 100;

	gfx_open(xsize,ysize,"Bounce!");

	for(;;) {
		print "x: ", x, " y: ", y, " vx: ", vx, " vy: ", vy, "\n";

		if(gfx_event_waiting()) {
			c: char;
			c = gfx_wait();
			if(c=='q') return 0;
			x = gfx_xpos()*precision;
			y = gfx_ypos()*precision;
			vx = 5*precision;
		}

		vy = vy + 1 * precision;

		if(x<0 && vx<0) {
			vx = -9*vx/10;
		}	

		if(x>(xsize*precision) && vx>0) {
			vx = -9*vx/10;
		}

		if(y>(ysize*precision) && vy>0) {
			vy = -9*vy/10;
		}

		x = x + vx*deltat/precision;
		y = y + vy*deltat/precision;

		gfx_clear();
		draw_box(x/precision,y/precision,25);
		gfx_flush();

		usleep(deltat*precision);
	}
}
===[good5.bminor Output]===
Success!

gfx_color resolves to global gfx_color
gfx_line resolves to global gfx_line
x resolves to param 0
y resolves to param 1
x resolves to param 0
size resolves to param 2
y resolves to param 1
gfx_line resolves to global gfx_line
x resolves to param 0
size resolves to param 2
y resolves to param 1
x resolves to param 0
size resolves to param 2
y resolves to param 1
size resolves to param 2
gfx_line resolves to global gfx_line
x resolves to param 0
size resolves to param 2
y resolves to param 1
size resolves to param 2
x resolves to param 0
y resolves to param 1
size resolves to param 2
gfx_line resolves to global gfx_line
x resolves to param 0
y resolves to param 1
size resolves to param 2
x resolves to param 0
y resolves to param 1
precision resolves to local 0
xsize resolves to local 1
precision resolves to local 0
ysize resolves to local 2
precision resolves to local 0
precision resolves to local 0
gfx_open resolves to global gfx_open
xsize resolves to local 1
ysize resolves to local 2
x resolves to local 3
y resolves to local 4
vx resolves to local 5
vy resolves to local 6
gfx_event_waiting resolves to global gfx_event_waiting
c resolves to local 8
gfx_wait resolves to global gfx_wait
c resolves to local 8
x resolves to local 3
gfx_xpos resolves to global gfx_xpos
precision resolves to local 0
y resolves to local 4
gfx_ypos resolves to global gfx_ypos
precision resolves to local 0
vx resolves to local 5
precision resolves to local 0
vy resolves to local 6
vy resolves to local 6
precision resolves to local 0
x resolves to local 3
vx resolves to local 5
vx resolves to local 5
vx resolves to local 5
x resolves to local 3
xsize resolves to local 1
precision resolves to local 0
vx resolves to local 5
vx resolves to local 5
vx resolves to local 5
y resolves to local 4
ysize resolves to local 2
precision resolves to local 0
vy resolves to local 6
vy resolves to local 6
vy resolves to local 6
x resolves to local 3
x resolves to local 3
vx resolves to local 5
deltat resolves to local 7
precision resolves to local 0
y resolves to local 4
y resolves to local 4
vy resolves to local 6
deltat resolves to local 7
precision resolves to local 0
gfx_clear resolves to global gfx_clear
draw_box resolves to global draw_box
x resolves to local 3
precision resolves to local 0
y resolves to local 4
precision resolves to local 0
gfx_flush resolves to global gfx_flush
usleep resolves to global usleep
deltat resolves to local 7
precision resolves to local 0


return code: 0


===[good6.bminor Input]===
main: function void() = {
	x:integer = 5;
	if( 4 < 5 )
		if( 10 < 20 )
			for(x = 0; x < 5; x++)
				if( 4 < 5 )
					print "helloo\n";
				else
					print "hello\n";
		else
			print "goodbye";
}
===[good6.bminor Output]===
Success!

x resolves to local 0
x resolves to local 0
x resolves to local 0


return code: 0


===[good7.bminor Input]===
//test expressions inside of array indexes
arr:array [5] integer = {0,1,2,3,4};

main:function void() =
{
	x:integer = 5;
	y:integer = 3;
	arr[x - y] = 4;
	arr[y + x * 3] = arr[2+ x^2 - 1];
} 
===[good7.bminor Output]===
Success!

arr resolves to global arr
x resolves to local 0
y resolves to local 1
arr resolves to global arr
y resolves to local 1
x resolves to local 0
arr resolves to global arr
x resolves to local 0


return code: 0


===[good8.bminor Input]===
main: function void(x: integer) = {
    x: integer = x;
}
===[good8.bminor Output]===
Success!

x resolves to param 0


return code: 0


===[good9.bminor Input]===
fib: function integer ( x: integer ) = {
    if (x<1) {
        return 0;
    } else {
        if (x<2) {
            return 1;
        } else {
            return fib(x-1)+fib(x-2);
        }
    }
}
===[good9.bminor Output]===
Success!

x resolves to param 0
x resolves to param 0
fib resolves to global fib
x resolves to param 0
fib resolves to global fib
x resolves to param 0


return code: 0


====Bad Tests====
===[bad0.bminor Input]===
// If-else cross-referencing variables

main: function void(x: integer) = {
    if (x>0) {
        inner: integer = 5;
        return elseinner;
    } else {
        elseinner: integer = 3;
        return inner;
    }
}
===[bad0.bminor Output]===
Success!

x resolves to param 0
resolve error: elseinner is not defined.
resolve error: inner is not defined.
2 resolve errors found.


return code: 1


===[bad1.bminor Input]===
// conflicting declaration
x: integer;
y: boolean;
z: void;
s: char;
t: string;
a: integer = 500000;
a: char = "this is a test";
z: float = 3E2;
b: boolean = true;
===[bad1.bminor Output]===
Success!

resolve error: duplicate definitions of a in the same scope is invalid.
resolve error: duplicate definitions of z in the same scope is invalid.
2 resolve errors found.


return code: 1


===[bad2.bminor Input]===
// multiple definition of function

helper: function integer ()= {
    return 42;
}

helper: function integer ()= {
    return 24;
}
===[bad2.bminor Output]===
Success!

resolve error: duplicate definitions of helper is invalid.
1 resolve errors found.


return code: 1


===[bad3.bminor Input]===
helper: function integer (x: integer);

helper: function integer ()= {
    return 24;
}
===[bad3.bminor Output]===
Success!

resolve error: definition of helper does not match prototype helper global 0.
1 resolve errors found.


return code: 1


===[bad4.bminor Input]===
main: function void () = {
    x = 5; // x used before it is declared
    x: integer ;
    return 0;

}
===[bad4.bminor Output]===
Success!

resolve error: x is not defined.
1 resolve errors found.


return code: 1


===[bad5.bminor Input]===
// redefinition

main: function void () = {
    x: integer = 5;
    x: integer =10;
    return 0;

}
===[bad5.bminor Output]===
Success!

resolve error: duplicate definitions of x in the same scope is invalid.
1 resolve errors found.


return code: 1


===[bad6.bminor Input]===
// wrong scope
doSomething: function void () ={
    localVar: integer = 10;
}

main: function integer() ={
    doSomething();
    localVar++; 
    return 0;
}
===[bad6.bminor Output]===
Success!

doSomething resolves to global doSomething
resolve error: localVar is not defined.
1 resolve errors found.


return code: 1


===[bad7.bminor Input]===
foo: function void();
foo: function void() = {}

bar: integer;
bar: function void(x: integer);
===[bad7.bminor Output]===
Success!

foo defines prototype global foo.
resolve error: different prototypes of bar is invalid.
1 resolve errors found.


return code: 1


===[bad8.bminor Input]===
foo: function void();
foo: function void() = {}

bar: function void();
bar: function void() = {}
bar: function void();
===[bad8.bminor Output]===
Success!

foo defines prototype global foo.
bar defines prototype global bar.
resolve error: prototype of bar after the definition of bar global 1.
1 resolve errors found.


return code: 1


===[bad9.bminor Input]===
// Multiple declarations in param list

main: function void (x: integer, x: float) = {
    return x;
}
===[bad9.bminor Output]===
Success!

resolve error: duplicate x is invalid.
x resolves to param 0
1 resolve errors found.


return code: 1


=====HIDDEN TESTS=====
====Good Tests====
===[good1.bminor Input]===
/* Correct: x used but not defined. */

x: integer = 10;

===[good1.bminor Output]===
Success!



return code: 0


===[good10.bminor Input]===
/* Correct: Many variables to resolve. */

D: function integer() = {
        d1: integer = 5;
        d2: integer = d1 + 1; //6
        {
                d3: integer = 9;
                d2: integer = d3 + d1 - 3; //11
                d4: integer = -1;
                d2 = d2 + d3; //20
                print d2 - d4, "\n";
        }
        d4: integer = 16;
        print d2 - d4, '\n';
        {
                d4: integer = -2;
                d3: integer = 1000;
                print d3 + 10;
                print "\n";
                print d4;
                print '\n';
        }
        print d4;
        return 3;
}

main: function integer () = {
        return D();
}

===[good10.bminor Output]===
Success!

d1 resolves to local 0
d3 resolves to local 2
d1 resolves to local 0
d2 resolves to local 3
d2 resolves to local 3
d3 resolves to local 2
d2 resolves to local 3
d4 resolves to local 4
d2 resolves to local 1
d4 resolves to local 5
d3 resolves to local 7
d4 resolves to local 6
d4 resolves to local 5
D resolves to global D


return code: 0


===[good2.bminor Input]===
/* Correct: redefining a name at the local scope. */

x: integer = 10;

f: function void () = {
     x: integer = 20;
     print x, "\n";
}


===[good2.bminor Output]===
Success!

x resolves to local 0


return code: 0


===[good3.bminor Input]===
/* Correct: redefining a name at the local scope. */

x: integer = 10;

f: function void ( a: integer, b: integer ) = {
     x: integer = 20;
     if(a<b) {
          x: integer = 30;
          print x, "\n";
     } else {
          print "a>=b\n";
     }
}



===[good3.bminor Output]===
Success!

a resolves to param 0
b resolves to param 1
x resolves to local 3


return code: 0


===[good4.bminor Input]===
/* Correct: Accessing names in different scopes. */

x: integer = 10;

f: function void ( a: integer, b: integer ) = {
     y: integer = 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }

}


===[good4.bminor Output]===
Success!

a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
z resolves to local 3


return code: 0


===[good5.bminor Input]===
/* Correct: f is called multiple times from main. */
/* (Should resolve the expression before adding the decl of y. */

x: integer = 10;

f: function void ( a: integer, b: integer ) = {
     y: integer = a * 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }
}

main: function integer ( argc: integer, argv: array [] string ) = {
     f(10,20);
     f(40,30);
}



===[good5.bminor Output]===
Success!

a resolves to param 0
a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
z resolves to local 3
f resolves to global f
f resolves to global f


return code: 0


===[good6.bminor Input]===
/* Correct: f is prototyped, then defined, then called. */

x: integer = 10;

f: function void ( a: integer, b: integer );

f: function void ( a: integer, b: integer ) = {
     y: integer = a * 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }
}

main: function integer ( argc: integer, argv: array [] string ) = {
     f(10,20);
     f(40,30);
}




===[good6.bminor Output]===
Success!

f defines prototype global f.
a resolves to param 0
a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
z resolves to local 3
f resolves to global f
f resolves to global f


return code: 0


===[good7.bminor Input]===
/* Correct: f is prototyped, then called, then defined. */

x: integer = 10;

f: function void ( a: integer, b: integer );

main: function integer ( argc: integer, argv: array [] string ) = {
     f(10,20);
     f(40,30);
}

f: function void ( a: integer, b: integer ) = {
     y: integer = a * 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }
}



===[good7.bminor Output]===
Success!

f resolves to global f
f resolves to global f
f defines prototype global f.
a resolves to param 0
a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
z resolves to local 3


return code: 0


===[good8.bminor Input]===
/* Correct: Resolver should work all the way down the tree. */

f: function void ( n:integer, s: string ) =
{
	i:integer;

	for(i=0;i<n;i++) { 
		if( i%2 == 0 ) {
			print i, "is even\n";
		} else {
			print i, "is odd\n";
		}
	}

	/* We can open a new scope with braces */
	{
		i: integer;
		j: integer;
		for(i=0;i<n;i++) {
			for(j=0;j<n;j++) {
				print i, ":", j, " -> ", i*j, " ", s, "\n";
			}
		}
	}
}

===[good8.bminor Output]===
Success!

i resolves to local 2
i resolves to local 2
n resolves to param 0
i resolves to local 2
i resolves to local 2
i resolves to local 2
i resolves to local 2
i resolves to local 3
i resolves to local 3
n resolves to param 0
i resolves to local 3
j resolves to local 4
j resolves to local 4
n resolves to param 0
j resolves to local 4
i resolves to local 3
j resolves to local 4
i resolves to local 3
j resolves to local 4
s resolves to param 1


return code: 0


===[good9.bminor Input]===
/* Correct: Different functions can define variables with same params and locals. */

x: integer = 10;

f: function integer ( x: integer ) =
{
	y: integer = 20;
	return x*y;
}

g: function void ( x: integer ) =
{
	y: integer = 30;
	return x*y;
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	return f(x) + g(x);
}

===[good9.bminor Output]===
Success!

x resolves to param 0
y resolves to local 1
x resolves to param 0
y resolves to local 1
f resolves to global f
x resolves to global x
g resolves to global g
x resolves to global x


return code: 0


===[good11.bminor Input]===
e: function integer () = {
        e: integer = 100;
	return e;
}

main: function integer () = {
        return e();
}

===[good11.bminor Output]===
Success!

e resolves to local 0
e resolves to global e


return code: 0


====Bad Tests====
===[bad1.bminor Input]===
/* Error: name already used in the global scope. */
x: integer = 10;
x: integer = 20;


===[bad1.bminor Output]===
Success!

resolve error: duplicate definitions of x in the same scope is invalid.
1 resolve errors found.


return code: 1


===[bad10.bminor Input]===
/* Error: Function has the same name as a declared variable. */

str: string = "hello";

str: function string ( s: string ) = 
{
	return "goodbye";
}


===[bad10.bminor Output]===
Success!

resolve error: different prototypes of str is invalid.
1 resolve errors found.


return code: 1


===[bad2.bminor Input]===
/* Error: Variable z went out of scope. */

x: integer = 10;

f: function void ( a: integer, b: integer ) = {
     y: integer = 20;
     if(a<b) {
          z: integer = 30;
	  print "a<b\n";
     }
     print x, " ", y, " ", z, "\n";
}


===[bad2.bminor Output]===
Success!

a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
resolve error: z is not defined.
1 resolve errors found.


return code: 1


===[bad3.bminor Input]===
/* Error: Cannot refer to variable y in its own definition. */
/* (Should resolve the expression before adding the decl of y. */

x: integer = 10;

f: function void ( a: integer, b: integer ) = {
     y: integer = y * 20;
     if(a<b) {
          z: integer = 30;
	  print "a<b\n";
     } else {
          print "a>=b\n";
     }
     print x, " ", y, " ", z, "\n";
}


===[bad3.bminor Output]===
Success!

resolve error: y is not defined.
a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
resolve error: z is not defined.
2 resolve errors found.


return code: 1


===[bad4.bminor Input]===
/* Error: f has multiple definitions. */

x: integer = 10;

f: function void ( a: integer, b: integer ) = {
     y: integer = y * 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }
}

f: function string ( s: string ) = {
    print "hello";
    return "goodbye";
}


===[bad4.bminor Output]===
Success!

resolve error: y is not defined.
a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
z resolves to local 3
resolve error: duplicate definitions of f is invalid.
2 resolve errors found.


return code: 1


===[bad5.bminor Input]===
/* Error: f is called prior to definition. */

x: integer = 10;

main: function integer ( argc: integer, argv: array [] string ) = {
     f(10,20);
     f(40,30);
}

f: function void ( a: integer, b: integer ) = {
     y: integer = y * 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }
}



===[bad5.bminor Output]===
Success!

resolve error: f is not defined.
resolve error: f is not defined.
resolve error: y is not defined.
a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
z resolves to local 3
3 resolve errors found.


return code: 1


===[bad6.bminor Input]===
/* Error: g is not defined. */

x: integer = 10;

f: function void ( a: integer, b: integer ) = {
     y: integer = y * 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }
}

main: function integer ( argc: integer, argv: array [] string ) = {
     f(10,20);
     g(40,30);
}


===[bad6.bminor Output]===
Success!

resolve error: y is not defined.
a resolves to param 0
b resolves to param 1
x resolves to global x
y resolves to local 2
z resolves to local 3
f resolves to global f
resolve error: g is not defined.
2 resolve errors found.


return code: 1


===[bad7.bminor Input]===
/* Error: Two parameters have the same name */
/* Also, b is not defined. */

f: function void ( a: integer, a: integer ) = {
     y: integer = y * 20;
     if(a<b) {
          z: integer = 30;
          print x, " ", y, " ", z, "\n";
     } else {
          print "a>=b\n";
     }
}

===[bad7.bminor Output]===
Success!

resolve error: duplicate a is invalid.
resolve error: y is not defined.
a resolves to param 0
resolve error: b is not defined.
resolve error: x is not defined.
y resolves to local 1
z resolves to local 2
4 resolve errors found.


return code: 1


===[bad8.bminor Input]===
/* Error: x not defined, deep down in the expression. */

a: integer;

f: function integer ( b: integer ) =
{
	c: integer;
	for(c=0;c<b;c++) {
		if(a<b) {
			print a + b * (c / (a+x)), "\n"; 
		}
	}
	return b;
}

===[bad8.bminor Output]===
Success!

c resolves to local 1
c resolves to local 1
b resolves to param 0
c resolves to local 1
a resolves to global a
b resolves to param 0
a resolves to global a
b resolves to param 0
c resolves to local 1
a resolves to global a
resolve error: x is not defined.
b resolves to param 0
1 resolve errors found.


return code: 1


===[bad9.bminor Input]===
/* Error: x redefined after several intervening scopes. */

a: integer;

f: function integer ( b: integer ) =
{
	x: integer = 20;
	{
		i: integer;
		for(i=0;i<x;i++) print i;
	}
	{
		j: integer;
		for(j=0;j<x;j++) print j;
	}
	x: integer = 30;

	return x;
}

===[bad9.bminor Output]===
Success!

i resolves to local 2
i resolves to local 2
x resolves to local 1
i resolves to local 2
i resolves to local 2
j resolves to local 3
j resolves to local 3
x resolves to local 1
j resolves to local 3
j resolves to local 3
resolve error: duplicate definitions of x in the same scope is invalid.
x resolves to local 1
1 resolve errors found.


return code: 1


===== SUMMARIZED PARSER RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 10,
      "incorrect": 0
    },
    "Bad": {
      "correct": 10,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 11,
      "incorrect": 0
    },
    "Bad": {
      "correct": 10,
      "incorrect": 0
    }
  }
}

Resolver Project Grade
-------------------

General Structure: 25/25
---------------------------------
Overall structure is correct.

Resolver - Manual Checks 25/25 
--------------------------------------------
resolve and scopes look good

Student Tests: 20/20
---------------------------
Passes all your tests.

Hidden Tests: 20/20
---------------------------
Passes all hidden tests

Code Style: 10/10
------------------------
Looks good. Great work!

Total: 100/100
------------------------------------------
