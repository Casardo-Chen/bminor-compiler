=====STUDENT TESTS=====
====Good Tests====
===[STUDENT TESTS/good0.bminor Input]===
main:function integer ()=
{	
	print 10;
}
===[STUDENT TESTS/good0.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good0.bminor Output]===




===[STUDENT TESTS/good1.bminor Input]===
// tests addition
main:function integer ()=
{
	return 8 + 2;
}
===[STUDENT TESTS/good1.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good1.bminor Output]===




===[STUDENT TESTS/good10.bminor Input]===
// tests character printing
i:char= 'i';
main:function integer () =
{
	n:char ='n';
	print 'h', i,' ', n, 'd'; 
}
===[STUDENT TESTS/good10.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good10.bminor Output]===
i resolves to global i
n resolves to local 0




===[STUDENT TESTS/good11.bminor Input]===
// tests comparisions/if statements
x:integer = 5;
main: function integer () =
{
	y:integer = 10;
	z:integer = 5;
    print "x=",x, '\n';
    print "y=",y, '\n';
    print "z=",z, '\n';
	if(x >= z)
		print "should be printed\n";
	else
	{
		print "shouldn't be printed\n";
	}

	if(y > x )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}
	if(z == x )
	{
		print "should be printed\n";
	}
	else
		print "shouldn't be printed\n";
	
	if(x <= y )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}
	if(x != y )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}


	//switched now (statement should be false)
	if(z < x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}

	if(y < x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	if(z != x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	
	if(y <= x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	if(y == x )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
}
===[STUDENT TESTS/good11.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good11.bminor Output]===
x resolves to global x
y resolves to local 0
z resolves to local 1
x resolves to global x
z resolves to local 1
y resolves to local 0
x resolves to global x
z resolves to local 1
x resolves to global x
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
z resolves to local 1
x resolves to global x
y resolves to local 0
x resolves to global x
z resolves to local 1
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
x resolves to global x




===[STUDENT TESTS/good12.bminor Input]===
// tests comparisions/if statements with chars
c:char = 'c';
main: function integer () =
{
	a:char = 'a';
	cdup:char = 'c';
	
	if(c == cdup )
	{
		print "should be printed\n";
	}
	else
		print "shouldn't be printed\n";
	
	if(c != a )
	{
		print "should be printed\n";
	}
	else
	{
		print "shouldn't be printed\n";
	}


	//switched now (statement should be false)
	if(c != cdup )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
	
	if(c == a )
	{
		print "shouldn't be printed\n";
	}
	else
	{
		print "should be printed\n";
	}
}
===[STUDENT TESTS/good12.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good12.bminor Output]===
c resolves to global c
cdup resolves to local 1
c resolves to global c
a resolves to local 0
c resolves to global c
cdup resolves to local 1
c resolves to global c
a resolves to local 0




===[STUDENT TESTS/good13.bminor Input]===
// tests for loops
x:integer = 1;
main: function integer () =
{
	for(x = 0; x<10; x++)
	{
		print x, "\n";
	}
	y:integer = 0;
	for(; y<10; y++)
	{
		print y, "\n";
	}
	x=0;
}
===[STUDENT TESTS/good13.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good13.bminor Output]===
x resolves to global x
x resolves to global x
x resolves to global x
x resolves to global x
y resolves to local 0
y resolves to local 0
y resolves to local 0
x resolves to global x




===[STUDENT TESTS/good14.bminor Input]===
// tests infinite for loops
x:integer = 1;
main: function integer () =
{
	for(;;)
	{
		if(x<10)
		{
			print x, "\n";
			x++;
		}
		else
		{
			return  10;
		}
	}	
}
===[STUDENT TESTS/good14.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good14.bminor Output]===
x resolves to global x
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good15.bminor Input]===
// tests strings/string assignments and printing 
str:string = "hello";
main:function integer () =
{
	print str;
	str2:string = " world";
	print str2;
}
===[STUDENT TESTS/good15.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good15.bminor Output]===
str resolves to global str
str2 resolves to local 0




===[STUDENT TESTS/good16.bminor Input]===
// tests strings and string comparisions
// and use of strings as local variables

str:string = "hello";
str2:string = " world";

main:function integer () =
{
	str3:string = str;
	if(str == str3)
	{
		print str;
	}
	else
	{
		print "shouldn't be printed";
	}
	if(str != str2)
	{
		print str2;
	}
	else
	{
		print "shouldn't be printed";
	}
}
===[STUDENT TESTS/good16.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good16.bminor Output]===
str resolves to global str
str resolves to global str
str3 resolves to local 0
str resolves to global str
str resolves to global str
str2 resolves to global str2
str2 resolves to global str2




===[STUDENT TESTS/good17.bminor Input]===
/*
Display fibonnaci numbers from 0 to 45.
This test exercises the ability of your
compiler to call recursive functions.
*/

fib: function integer ( x: integer ) =
{
	if( x<1 ) {
		return 0;
	} else {
		if(x<2) {
			return 1;
		} else {
			return fib(x-1) + fib(x-2);
		}
	}
}

main: function integer ( argc: integer, argv: array [] string ) =
{
	i: integer;

	print "Table of Fibonnacci Numbers\n";

	for(i=0;i<30;i=i+1) {
		print i, " ", fib(i), "\n";
	}

	return 0;
}

===[STUDENT TESTS/good17.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good17.bminor Output]===
x resolves to param 0
x resolves to param 0
fib resolves to global fib
x resolves to param 0
fib resolves to global fib
x resolves to param 0
i resolves to local 2
i resolves to local 2
i resolves to local 2
i resolves to local 2
i resolves to local 2
fib resolves to global fib
i resolves to local 2




===[STUDENT TESTS/good18.bminor Input]===
// tests boolean operations
x:integer = 1;
main: function string () =
{
    y: integer = 12;
	if(x == 1 && y<13)
	{
        if(x > 1 || y<13) print "x= ", x, "\n";
		x++;
        print "should be printed";
	}
	else
	{
        print "shouldn't be printed";
		return  "wrong";
	}	
}
===[STUDENT TESTS/good18.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good18.bminor Output]===
x resolves to global x
y resolves to local 0
x resolves to global x
y resolves to local 0
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good19.bminor Input]===
// tests for array
a: array [5] integer = {1,2,3,4,5};

main: function integer () =
{
    x:integer;
	for(x = 0; x<5; x++)
	{
		print a[x], "\n";
	}
}
===[STUDENT TESTS/good19.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good19.bminor Output]===
x resolves to local 0
x resolves to local 0
x resolves to local 0
a resolves to global a
x resolves to local 0




===[STUDENT TESTS/good2.bminor Input]===
// tests multiplication
main:function integer ()=
{
	return 5 * 2;
}
===[STUDENT TESTS/good2.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good2.bminor Output]===




===[STUDENT TESTS/good3.bminor Input]===
// tests division
main:function integer ()=
{
	return 20 / 2;
}
===[STUDENT TESTS/good3.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good3.bminor Output]===




===[STUDENT TESTS/good4.bminor Input]===
// Adds a global variable
x:integer=5;
main:function integer ()=
{
	print x + x;
}
===[STUDENT TESTS/good4.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good4.bminor Output]===
x resolves to global x
x resolves to global x




===[STUDENT TESTS/good5.bminor Input]===
// Test expo
x:integer=5;
main:function integer ()=
{
	print x ^ 3;
}
===[STUDENT TESTS/good5.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good5.bminor Output]===
x resolves to global x




===[STUDENT TESTS/good6.bminor Input]===
// Adds a local variable
x:integer=5;
main:function integer ()=
{
y:integer = 2;
	return x * y;
}
===[STUDENT TESTS/good6.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good6.bminor Output]===
x resolves to global x
y resolves to local 0




===[STUDENT TESTS/good7.bminor Input]===
// Uses a complex expression
x:integer=5;
main:function integer () =
{
	y:integer = 2;
	print (x + 10) * y - x*4;
    return (x + 10) * y - x*4;
}
===[STUDENT TESTS/good7.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good7.bminor Output]===
x resolves to global x
y resolves to local 0
x resolves to global x
x resolves to global x
y resolves to local 0
x resolves to global x




===[STUDENT TESTS/good8.bminor Input]===
// Uses a complex expression, with a function call
x:integer=5;
fxnCall:function integer() =
{
	return x*4;
}
main:function integer () =
{
	y:integer = 2;
	return (x + 10) * y - fxnCall();
}
===[STUDENT TESTS/good8.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good8.bminor Output]===
x resolves to global x
x resolves to global x
y resolves to local 0
fxnCall resolves to global fxnCall




===[STUDENT TESTS/good9.bminor Input]===
// tests if statements 
x:integer = 5;
main:function integer () =
{
	if(false)
		x=15;
	else
		x=10;

	if(true)
	{
		return x;
	}
	else
	{
		return 1;
	}	
	
}
===[STUDENT TESTS/good9.bminor Status]===
return code: 0
Test passed successfully!

===[STUDENT TESTS/good9.bminor Output]===
x resolves to global x
x resolves to global x
x resolves to global x




====Bad Tests====
=====HIDDEN TESTS=====
====Good Tests====
====Bad Tests====
===== SUMMARIZED PRINTER RESULTS =====
{
  "student_tests": {
    "Good": {
      "correct": 20,
      "incorrect": 0
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  },
  "hidden_tests": {
    "Good": {
      "correct": 0,
      "incorrect": 0
    },
    "Bad": {
      "correct": 0,
      "incorrect": 0
    }
  }
}

Printer Project
---------------

Continued correctness of the -scan, -parse, -print, and -resolve options (30/30 points)
----------------------------------------------
Scanning, parsing, printing, and resolving all seem to be correct.

General correctness of the -typecheck option. (20/20 points)
----------------------------------------------
Typechecking looks to be done correctly

Student Tests (20/20 points)
------------------------------------------
Nice test coverage

Hidden Tests (0/20 points)
------------------------------------------
Good work passing all of the hidden tests

Coding Style (10/10 points)
------------------------------------------
Coding style looks quite nice. Well done!

---------------
